

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/img/blog/fav.jpg">
  <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/img/blog/fav.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="codeAtrox">
  <meta name="keywords" content="">
  <title>数据结构：树 - Atrox的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>AtroxQW</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg/atrox1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据结构：树">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-02-19 17:59" pubdate>
        February 19, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      164
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构：树</h1>
            
            <div class="markdown-body">
              <h2 id="一、树"><a href="#一、树" class="headerlink" title="一、树"></a>一、树</h2><h3 id="1-为什么需要树"><a href="#1-为什么需要树" class="headerlink" title="1.为什么需要树"></a>1.为什么需要树</h3><p><strong>数组存储方式分析</strong>：</p>
<p><strong>优点</strong>：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。</p>
<p><strong>缺点</strong>：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低</p>
<p><strong>链式存储方式分析</strong>：</p>
<p><strong>优点</strong>：：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。</p>
<p><strong>缺点</strong>：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)</p>
<p><strong>树存储方式分析</strong>：</p>
<p>能提高数据存储，读取的效率, 比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</p>
<h3 id="2-树的常用术语"><a href="#2-树的常用术语" class="headerlink" title="2.树的常用术语"></a>2.树的常用术语</h3><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/1.png" srcset="/img/loading.gif" alt="术语" style="zoom:80%;">

<p><strong>树的术语</strong>（结合示意图理解）</p>
<ul>
<li>节点</li>
<li>根节点</li>
<li>父节点</li>
<li>子节点</li>
<li>叶子节点（没有子节点的节点）</li>
<li>节点的权（节点的值）</li>
<li>路径（从根节点到该节点的路线）</li>
<li>度（节点的子节点数量）</li>
<li>层</li>
<li>子树</li>
<li>树的深度（最大层数）</li>
<li>森林（多棵子树组成森林）</li>
</ul>
<hr>
<h2 id="二、二叉树基本内容"><a href="#二、二叉树基本内容" class="headerlink" title="二、二叉树基本内容"></a>二、二叉树基本内容</h2><h3 id="1-二叉树的定义"><a href="#1-二叉树的定义" class="headerlink" title="1.二叉树的定义"></a>1.二叉树的定义</h3><p><strong>二叉树</strong>的特点是每个节点至多只能有两棵子树（即二叉树中不存在度大于2的节点），并且，<strong>二叉树的子树有左右之分，其次序不能任意颠倒</strong>。</p>
<h3 id="2-二叉树的性质"><a href="#2-二叉树的性质" class="headerlink" title="2.二叉树的性质"></a>2.二叉树的性质</h3><ol>
<li><p>性质1：<strong>在二叉树的第 i 层上，至多有2^i-1^个节点。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/2.png" srcset="/img/loading.gif" alt="性质1" style="zoom:80%;">
</li>
<li><p>性质2：<strong>深度为 k 的二叉树的最大节点数为 2^k^-1</strong></p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/3.png" srcset="/img/loading.gif" alt="性质2" style="zoom:80%;">
</li>
<li><p>性质3：<strong>对任何一个二叉树 T，如果其叶子节点数为 n<del>0</del>，度数为2的节点为n<del>2</del>，则n<del>0</del> = n<del>2</del>+1 。即：叶子节点比度数为2的节点多一个。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/4.png" srcset="/img/loading.gif" alt="性质3" style="zoom:80%;">
</li>
<li><p>性质4：<strong>如果二叉树的深度为 k，节点数为 2^k^ - 1 ，即该二叉树的所有叶子节点都在最后一层，该二叉树为满二叉树</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/5.png" srcset="/img/loading.gif" alt="性质4" style="zoom:80%;">
</li>
<li><p>性质5：<strong>如果该二叉树的的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/6.png" srcset="/img/loading.gif" alt="性质5" style="zoom:80%;">
</li>
<li><p>性质6：<strong>具有 n 个节点的完全二叉树的深度为【log<del>2</del>n】(向下取整)+1</strong> 。 </p>
</li>
<li><p>性质7：<strong>如果父节点编号（根节点编号为1）为 i，则其左孩子节点编号为2i，右孩子节点编号为2i+1</strong></p>
</li>
</ol>
<h3 id="3-二叉树存储结构"><a href="#3-二叉树存储结构" class="headerlink" title="3. 二叉树存储结构"></a>3. 二叉树存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 二叉树类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BiNode root;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(BiNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.root = root;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 二叉树节点类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiNode</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 左右孩子指针</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> BiNode leftChild,rightChild;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BiNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.data = data;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="4-二叉树遍历"><a href="#4-二叉树遍历" class="headerlink" title="4.二叉树遍历"></a>4.二叉树遍历</h3><h4 id="3-1-先序遍历"><a href="#3-1-先序遍历" class="headerlink" title="3.1 先序遍历"></a>3.1 先序遍历</h4><p>先序遍历：先输出父节点，再遍历做左子树，再遍历右子树。</p>
<p><strong>思路：</strong></p>
<ul>
<li>输出当前节点（初始时为root节点）</li>
<li>如果左子节点不为空，则递归继续先序遍历</li>
<li>如果右子节点不为空，则递归继续先序遍历。</li>
</ul>
<h4 id="3-2-中序遍历"><a href="#3-2-中序遍历" class="headerlink" title="3.2 中序遍历"></a>3.2 中序遍历</h4><p>中序遍历：先遍历左子树，再输出当前节点，再遍历右子树。</p>
<p><strong>思路：</strong></p>
<ul>
<li><p>如果左子节点不为空，则递归继续先序遍历</p>
</li>
<li><p>输出当前节点（初始时为root节点）</p>
</li>
<li><p>如果右子节点不为空，则递归继续先序遍历。</p>
</li>
</ul>
<h4 id="3-3-后序遍历"><a href="#3-3-后序遍历" class="headerlink" title="3.3 后序遍历"></a>3.3 后序遍历</h4><p>后序遍历：先遍历左子树，再遍历右子树，再输出当前节点。</p>
<p><strong>思路：</strong></p>
<ul>
<li><p>如果左子节点不为空，则递归继续先序遍历</p>
</li>
<li><p>如果右子节点不为空，则递归继续先序遍历。</p>
</li>
<li><p>输出当前节点（初始时为root节点）</p>
</li>
</ul>
<h4 id="3-4-代码实现"><a href="#3-4-代码实现" class="headerlink" title="3.4 代码实现"></a>3.4 代码实现</h4><p>创建如下所示的二叉树，并进行先序、中序、后序遍历。</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/7.png" srcset="/img/loading.gif" alt="图片" style="zoom:80%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Aatrox</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 二叉树类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-02-20 11:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> BiNode root;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinaryTree</span><span class="hljs-params">(BiNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.root = root;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 先序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.root.preOrderTraverse();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;当前二叉树为空&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 中序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.root.inOrderTraverse();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;当前二叉树为空&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 后序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.root.postOrderTraverse();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;当前二叉树为空&quot;</span>);<br>    &#125;<br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 二叉树节点类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiNode</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 左右孩子指针</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> BiNode leftChild,rightChild;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BiNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.data = data;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> data;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.data = data;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> BiNode <span class="hljs-title">getLeftChild</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> leftChild;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeftChild</span><span class="hljs-params">(BiNode leftChild)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.leftChild = leftChild;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> BiNode <span class="hljs-title">getRightChild</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> rightChild;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRightChild</span><span class="hljs-params">(BiNode rightChild)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.rightChild = rightChild;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;BiNode&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;data=&quot;</span> + data +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 先序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-keyword">this</span>.toString());<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.leftChild != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.leftChild.preOrderTraverse();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rightChild != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.rightChild.preOrderTraverse();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 中序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.leftChild != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.leftChild.inOrderTraverse();<br>    &#125;<br>    System.out.println(<span class="hljs-keyword">this</span>.toString());<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rightChild != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.rightChild.inOrderTraverse();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 后序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.leftChild != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.leftChild.postOrderTraverse();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rightChild != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.rightChild.postOrderTraverse();<br>    &#125;<br>    System.out.println(<span class="hljs-keyword">this</span>.toString());<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-5-测试类"><a href="#3-5-测试类" class="headerlink" title="3.5 测试类"></a>3.5 测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTreeTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 创建二叉树</span><br>    BinaryTree binaryTree = <span class="hljs-keyword">new</span> BinaryTree();<br><br>    <span class="hljs-comment">// 创建结点</span><br>    BiNode root = <span class="hljs-keyword">new</span> BiNode(<span class="hljs-number">1</span>);<br>    BiNode node2 = <span class="hljs-keyword">new</span> BiNode(<span class="hljs-number">2</span>);<br>    BiNode node3 = <span class="hljs-keyword">new</span> BiNode(<span class="hljs-number">3</span>);<br>    BiNode node4 = <span class="hljs-keyword">new</span> BiNode(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 手动创建二叉树</span><br>    binaryTree.setRoot(root);<br>    root.setLeftChild(node2);<br>    root.setRightChild(node3);<br>    node3.setRightChild(node4);<br><br>    System.out.println(<span class="hljs-string">&quot;先序遍历&quot;</span>);<br>    binaryTree.preOrderTraverse();<br>    System.out.println(<span class="hljs-string">&quot;中序遍历&quot;</span>);<br>    binaryTree.inOrderTraverse();<br>    System.out.println(<span class="hljs-string">&quot;后序遍历&quot;</span>);<br>    binaryTree.postOrderTraverse();<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">先序遍历<br>BiNode&#123;data=1&#125;<br>BiNode&#123;data=2&#125;<br>BiNode&#123;data=3&#125;<br>BiNode&#123;data=4&#125;<br>中序遍历<br>BiNode&#123;data=2&#125;<br>BiNode&#123;data=1&#125;<br>BiNode&#123;data=3&#125;<br>BiNode&#123;data=4&#125;<br>后序遍历<br>BiNode&#123;data=2&#125;<br>BiNode&#123;data=4&#125;<br>BiNode&#123;data=3&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-二叉树查找节点"><a href="#5-二叉树查找节点" class="headerlink" title="5. 二叉树查找节点"></a>5. 二叉树查找节点</h3><h4 id="5-1-要求"><a href="#5-1-要求" class="headerlink" title="5.1 要求"></a>5.1 要求</h4><p>编写先序查找，中序查找和后序查找的方法。并使用三种查找方式，查找结点值为data的结点。</p>
<h4 id="5-2-思路"><a href="#5-2-思路" class="headerlink" title="5.2 思路"></a>5.2 思路</h4><p><strong>先序查找思路</strong></p>
<ul>
<li>先判断当前节点的data是否等于要查找结点的值</li>
<li>如果相等，则返回当前结点</li>
<li>如果不等，则判断当前结点的左子节点是否为空，如果不为空，则递归先序查找</li>
<li>如果左递归先序查找找到了结点，则返回该节点。否则判断当前结点的右子节点是否为空，如果不为空，则继续向右的递归先序查找</li>
</ul>
<p><strong>中序查找和后序查找思路相似</strong></p>
<h4 id="5-3-代码"><a href="#5-3-代码" class="headerlink" title="5.3 代码"></a>5.3 代码</h4><p><strong>二叉树节点类方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiNode</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 左右孩子指针</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> BiNode leftChild,rightChild;<br><br>  ...........................<br>    <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 先序遍历查找节点</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> targetValue 节点值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 返回该节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> BiNode <span class="hljs-title">preOrderSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;<br>    <span class="hljs-comment">// 承接查找到的节点</span><br>    BiNode resNode = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.data == targetValue) &#123;<br>      resNode = <span class="hljs-keyword">this</span>;<br>      <span class="hljs-keyword">return</span> resNode;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.leftChild != <span class="hljs-keyword">null</span>) &#123;<br>      resNode = <span class="hljs-keyword">this</span>.leftChild.preOrderSearch(targetValue);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (resNode != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> resNode;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rightChild != <span class="hljs-keyword">null</span>) &#123;<br>      resNode = <span class="hljs-keyword">this</span>.rightChild.preOrderSearch(targetValue);<br>    &#125;<br>    <span class="hljs-keyword">return</span> resNode;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>二叉树类方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> BiNode root;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(BiNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.root = root;<br>  &#125;<br>    <br>  ...................................<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 先序查找节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> BiNode <span class="hljs-title">preOrderSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> root.preOrderSearch(targetValue);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;当前二叉树为空&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-二叉树删除节点"><a href="#6-二叉树删除节点" class="headerlink" title="6. 二叉树删除节点"></a>6. 二叉树删除节点</h3><h4 id="6-1-要求"><a href="#6-1-要求" class="headerlink" title="6.1 要求"></a>6.1 要求</h4><ul>
<li>如果删除的节点是叶子节点，则删除该节点。</li>
<li>如果删除的节点是非叶子节点，则删除该子树</li>
</ul>
<h4 id="6-2-思路"><a href="#6-2-思路" class="headerlink" title="6.2 思路"></a>6.2 思路</h4><ul>
<li><p>因为我们的二叉树是单向的，所以我们判断当前节点的子节点是否需要删除，二不是去判断当前节点是否需要删除。</p>
</li>
<li><p>首先考虑如果树本身是空树，如果该树只有一个root节点并且为应该被删除节点，则等价于将二叉树置空。</p>
</li>
<li><p>如果当前节点的左子节点不为空，并且左子节点就是要删除的节点，就<code>this.leftChild == null</code>，并且返回。</p>
</li>
<li><p>如果当前节点的右子节点不为空，并且右子节点就是要删除的节点，就<code>this.rightChild == null</code>，并且返回。</p>
</li>
<li><p>如果上面两步都没有完成删除节点，那么我们就需要先向左子树进行递归删除。</p>
</li>
<li><p>如果像左子树递归删除没有完成删除节点，我们需要向右子树进行递归删除。</p>
</li>
</ul>
<h4 id="6-3-代码"><a href="#6-3-代码" class="headerlink" title="6.3 代码"></a>6.3 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 二叉树类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BiNode root;<br><br>    .............<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (root.getData() == targetValue) &#123;<br>                root = <span class="hljs-keyword">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                root.delNode(targetValue);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;该二叉树为空，无法删除！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 二叉树节点类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiNode</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 左右孩子指针</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> BiNode leftChild,rightChild;<br>    <br>  ..........<br> <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 删除节点</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> targetValue 待删除节点值</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.leftChild != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.leftChild.data == targetValue) &#123;<br>      <span class="hljs-keyword">this</span>.leftChild = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rightChild != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.rightChild.data == targetValue) &#123;<br>      <span class="hljs-keyword">this</span>.rightChild = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.leftChild != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.leftChild.delNode(targetValue);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rightChild != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.rightChild.delNode(targetValue);<br>    &#125;<br><br>  &#125;<br>      <br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="6-4-测试"><a href="#6-4-测试" class="headerlink" title="6.4 测试"></a>6.4 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 创建二叉树</span><br>    BinaryTree binaryTree = <span class="hljs-keyword">new</span> BinaryTree();<br><br>    <span class="hljs-comment">// 创建结点</span><br>    BiNode root = <span class="hljs-keyword">new</span> BiNode(<span class="hljs-number">1</span>);<br>    BiNode node2 = <span class="hljs-keyword">new</span> BiNode(<span class="hljs-number">2</span>);<br>    BiNode node3 = <span class="hljs-keyword">new</span> BiNode(<span class="hljs-number">3</span>);<br>    BiNode node4 = <span class="hljs-keyword">new</span> BiNode(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 手动创建二叉树</span><br>    binaryTree.setRoot(root);<br>    root.setLeftChild(node2);<br>    root.setRightChild(node3);<br>    node3.setRightChild(node4);<br>    <br>    System.out.println(<span class="hljs-string">&quot;删除前&quot;</span>);<br>    binaryTree.preOrderTraverse();<br>    binaryTree.delNode(<span class="hljs-number">4</span>);<br>    System.out.println(<span class="hljs-string">&quot;删除后&quot;</span>);<br>    binaryTree.preOrderTraverse();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">删除前<br>BiNode&#123;data=1&#125;<br>BiNode&#123;data=2&#125;<br>BiNode&#123;data=3&#125;<br>BiNode&#123;data=4&#125;<br>删除后<br>BiNode&#123;data=1&#125;<br>BiNode&#123;data=2&#125;<br>BiNode&#123;data=3&#125;<br></code></pre></td></tr></table></figure>

<h3 id="7-创建二叉树"><a href="#7-创建二叉树" class="headerlink" title="7. 创建二叉树"></a>7. 创建二叉树</h3><h4 id="7-1-要求"><a href="#7-1-要求" class="headerlink" title="7.1 要求"></a>7.1 要求</h4><p>按照一维数组构建二叉树，构造下面的二叉树，需要传入数组[1, 2, 3, 4, 5, 6, 7]</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/9.png" srcset="/img/loading.gif" alt="tree" style="zoom:75%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一维数组构建二叉树</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> BiNode <span class="hljs-title">createBiTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br><br>    BiNode root = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">if</span> (index &gt;= arr.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    root = <span class="hljs-keyword">new</span> BiNode(arr[index]);<br>    root.setLeftChild(createBiTree(arr, <span class="hljs-number">2</span>*index+<span class="hljs-number">1</span>));<br>    root.setRightChild(createBiTree(arr, <span class="hljs-number">2</span>*index+<span class="hljs-number">2</span>));<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="7-3-测试"><a href="#7-3-测试" class="headerlink" title="7.3 测试"></a>7.3 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 创建二叉树</span><br>    BinaryTree binaryTree = <span class="hljs-keyword">new</span> BinaryTree();<br><br>    <span class="hljs-comment">// 方法建立二叉树</span><br>    <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>    binaryTree.setRoot(binaryTree.createBiTree(arr, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// 先序遍历</span><br>    binaryTree.preOrderTraverse();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">BiNode&#123;data=<span class="hljs-number">1</span>&#125;<br>BiNode&#123;data=<span class="hljs-number">2</span>&#125;<br>BiNode&#123;data=<span class="hljs-number">4</span>&#125;<br>BiNode&#123;data=<span class="hljs-number">5</span>&#125;<br>BiNode&#123;data=<span class="hljs-number">3</span>&#125;<br>BiNode&#123;data=<span class="hljs-number">6</span>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="三、线索化二叉树"><a href="#三、线索化二叉树" class="headerlink" title="三、线索化二叉树"></a>三、线索化二叉树</h2><h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h4><p>我们知道遍历二叉树可以得到二叉树结点中的某种序列。在这个线性序列中，每个结点有且仅有一个直接前驱和直接后继。</p>
<p>但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在任一序列中的前驱和后继信息</p>
<p>我们试着做如下规定，若结点有左子树，则其leftChild域指示其左孩子，否则令leftChild指示前驱；若结点有右子树，则其rightChild指示其右孩子，否则令rightChild指示后继。为了避免混淆，增加两个标志域leftTag和rightTag，其中：</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/11.png" srcset="/img/loading.gif" alt="线索链表">

<p><code>leftTag = 0</code>代表leftchild指向左孩子，<code>leftTag = 1</code>代表leftchild指向前驱。<br>        <code>rightTag = 0</code>代表rightchild指向右孩子，<code>rightTag = 1</code>代表rightchild指向后继。</p>
<p>以这种结点结构构成的二叉链表作为二叉树的存储结构，<strong>叫做线索链表</strong>，其中指向结点前驱和结点后继的指针，叫做<strong>线索</strong>。加上线索的二叉树被称为<strong>线索二叉树</strong>。</p>
<h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h4><p><strong>存储结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiThrNode</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;<br>  <span class="hljs-keyword">private</span> BiThrNode left;<br>  <span class="hljs-keyword">private</span> BiThrNode right;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 1.leftType：默认为0，指向左子树；为1，指向前驱</span><br><span class="hljs-comment">   * 2.rightType:默认为0，指向右子树；为1，指向后继</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> leftType;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rightType;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> data;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.data = data;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> BiThrNode <span class="hljs-title">getLeft</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> left;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeft</span><span class="hljs-params">(BiThrNode left)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.left = left;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> BiThrNode <span class="hljs-title">getRight</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> right;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRight</span><span class="hljs-params">(BiThrNode right)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.right = right;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLeftType</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> leftType;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeftType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> leftType)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.leftType = leftType;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRightType</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> rightType;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRightType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rightType)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.rightType = rightType;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>中序线索二叉树方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 中序线索二叉树</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderThreading</span><span class="hljs-params">(BiThrNode node)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 线索化左子树</span><br>    inOrderThreading(node.getLeft());<br><br>    <span class="hljs-comment">// 处理前驱结点</span><br>    <span class="hljs-keyword">if</span> (node.getLeft() == <span class="hljs-keyword">null</span>) &#123;<br>        node.setLeft(pre);<br>        node.setLeftType(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 在下一轮处理后继结点</span><br>    <span class="hljs-keyword">if</span> (pre != <span class="hljs-keyword">null</span> &amp;&amp; pre.getRight() == <span class="hljs-keyword">null</span>) &#123;<br>        pre.setRight(node);<br>        pre.setRightType(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 每处理一个结点后，让当前结点是下一个结点的前驱节点</span><br>    pre = node;<br><br>    <span class="hljs-comment">// 线索化右子树</span><br>    inOrderThreading(node.getRight());<br><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="四、树和森林"><a href="#四、树和森林" class="headerlink" title="四、树和森林"></a>四、树和森林</h2><h3 id="1-树的存储结构"><a href="#1-树的存储结构" class="headerlink" title="1.树的存储结构"></a>1.树的存储结构</h3><h4 id="1-1-双亲表示法"><a href="#1-1-双亲表示法" class="headerlink" title="1.1 双亲表示法"></a>1.1 双亲表示法</h4><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/12.png" srcset="/img/loading.gif" alt="双亲表示法">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 树的结点类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PTreeNode</span> </span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> data;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">   	 * 双亲位置域</span><br><span class="hljs-comment">   	 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> parentLoc;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PTree</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> PTreeNode[] nodes;<br>    <span class="hljs-keyword">public</span> PTreeNode root;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> nodeNum;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="1-2-孩子表示法"><a href="#1-2-孩子表示法" class="headerlink" title="1.2 孩子表示法"></a>1.2 孩子表示法</h4><p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/13.png" srcset="/img/loading.gif" alt="孩子表示法"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 孩子节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CTreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-keyword">public</span> CTreeNode next;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 孩子链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CTreeBox</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> data;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 孩子链表头指针</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> CTreeNode head<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CTree</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> CTreeBox[] childNodes;<br>    <span class="hljs-keyword">public</span> CTreeNode root;<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> nodeNum;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-3-孩子兄弟表示法"><a href="#1-3-孩子兄弟表示法" class="headerlink" title="1.3 孩子兄弟表示法"></a>1.3 孩子兄弟表示法</h4><p>孩子兄弟表示法又称二叉树表示法，或二叉链表表示法。即以二叉链表作为树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟节点。</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/14.png" srcset="/img/loading.gif" alt="二叉链表表示法" style="zoom:80%;">



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 结点类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CSNode</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-keyword">public</span> CSNode firstchild;<br>    <span class="hljs-keyword">public</span> CSNode nextsibling;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CSTree</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> CSNode root;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-森林和二叉树的转换"><a href="#2-森林和二叉树的转换" class="headerlink" title="2. 森林和二叉树的转换"></a>2. 森林和二叉树的转换</h3><p>具体参考知乎文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/134251528">https://zhuanlan.zhihu.com/p/134251528</a></p>
<p>具体参考博客园文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhuyf87/archive/2012/11/04/2753950.html">https://www.cnblogs.com/zhuyf87/archive/2012/11/04/2753950.html</a></p>
<h4 id="2-1-多叉树向二叉树的转换方法"><a href="#2-1-多叉树向二叉树的转换方法" class="headerlink" title="2.1 多叉树向二叉树的转换方法"></a>2.1 多叉树向二叉树的转换方法</h4><p>（1）加虚线：同一个父节点的相邻兄弟节点之间加虚线。</p>
<p>（2）抹实线：每个节点只保留它与最左子节点的连线，与其他子节点的连线全都抹掉。</p>
<p>（3）虚改实：虚线改为实线。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/15.png" srcset="/img/loading.gif" alt="多叉树-&gt;二叉树"></p>
<h4 id="2-2-森林向二叉树的转换方法"><a href="#2-2-森林向二叉树的转换方法" class="headerlink" title="2.2 森林向二叉树的转换方法"></a>2.2 森林向二叉树的转换方法</h4><p>（1）把每一棵树转换为二叉树。</p>
<p>（2）保留第一棵二叉树，自第二棵二叉树始，依次将后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，当所有的二叉树依此相连后，所得到的二叉树就是由森林转化成的二叉树。</p>
<p>（3）以树根为轴心，将整棵树按顺时钟方向旋转约45° 。</p>
<p>&lt;img src=”<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/16.png&quot;">https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/16.png&quot;</a> alt=”森林- style=”zoom: 25%;” &gt;二叉树” /&gt;</p>
<h4 id="2-3-二叉树恢复为森林的方法"><a href="#2-3-二叉树恢复为森林的方法" class="headerlink" title="2.3 二叉树恢复为森林的方法"></a>2.3 二叉树恢复为森林的方法</h4><p>将当前根结点和其左子树作为森林的一棵树，并将其右子树作为 森林的其他子树；重复上面直到某结点的右子树为空。</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/17.png" srcset="/img/loading.gif" alt="二叉树-  >森林">

<h4 id="2-4-二叉树恢复为多叉树的方法"><a href="#2-4-二叉树恢复为多叉树的方法" class="headerlink" title="2.4 二叉树恢复为多叉树的方法"></a>2.4 二叉树恢复为多叉树的方法</h4><p>（1）加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。</p>
<p>（2）去线。删除原二叉树中所有结点与其右孩子结点的连线。</p>
<p>（3）层次调整。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/18.png" srcset="/img/loading.gif" alt="二叉树-&gt;多叉树"></p>
<h3 id="3-树和森林的遍历"><a href="#3-树和森林的遍历" class="headerlink" title="3.树和森林的遍历"></a>3.树和森林的遍历</h3><h4 id="3-1-树的遍历"><a href="#3-1-树的遍历" class="headerlink" title="3.1 树的遍历"></a>3.1 树的遍历</h4><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/19.png" srcset="/img/loading.gif" alt="树的遍历" style="zoom:80%;">

<h4 id="3-2-森林的遍历"><a href="#3-2-森林的遍历" class="headerlink" title="3.2 森林的遍历"></a>3.2 森林的遍历</h4><p>1.<strong>先序遍历森林</strong></p>
<ul>
<li>访问森林中第一棵树的根节点。</li>
<li>先序遍历第一棵树的根节点的子树。</li>
<li>先序遍历去掉第一棵树后的子森林。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/20.png" srcset="/img/loading.gif" alt="先序遍历森林"></p>
<p>2.<strong>中序遍历森林</strong></p>
<ul>
<li>中序遍历第一棵树的根节点的子树。</li>
<li>访问森林中第一棵树的根节点。</li>
<li>中序遍历去掉第一棵树后的子森林。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/21.png" srcset="/img/loading.gif" alt="中序遍历"></p>
<h3 id="4-树、二叉树、森林遍历方式的对应关系"><a href="#4-树、二叉树、森林遍历方式的对应关系" class="headerlink" title="4. 树、二叉树、森林遍历方式的对应关系"></a>4. 树、二叉树、森林遍历方式的对应关系</h3><table>
<thead>
<tr>
<th align="center">树</th>
<th align="center">二叉树</th>
<th align="center">森林</th>
</tr>
</thead>
<tbody><tr>
<td align="center">先序遍历</td>
<td align="center">先序遍历</td>
<td align="center">先序遍历</td>
</tr>
<tr>
<td align="center">后序遍历</td>
<td align="center">中序遍历</td>
<td align="center">后序遍历</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、赫夫曼树及其应用"><a href="#五、赫夫曼树及其应用" class="headerlink" title="五、赫夫曼树及其应用"></a>五、赫夫曼树及其应用</h2><h3 id="1-重要概念"><a href="#1-重要概念" class="headerlink" title="1. 重要概念"></a>1. 重要概念</h3><h4 id="1-1-路径与路径长度"><a href="#1-1-路径与路径长度" class="headerlink" title="1.1 路径与路径长度"></a>1.1 路径与路径长度</h4><p>在一棵数中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目成为路径长度，若规定根节点的层数为1，则从根节点到第L层节点的路径长度为L-1。</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/22.png" srcset="/img/loading.gif" alt="路径" style="zoom:80%;">

<h4 id="1-2-结点的权与带权路径长度"><a href="#1-2-结点的权与带权路径长度" class="headerlink" title="1.2 结点的权与带权路径长度"></a>1.2 结点的权与带权路径长度</h4><p>若给树中结点赋予一个有着某种含义的数值，则这个数值成为该结点的权。<strong>结点的带权路径长度</strong>为：从根结点到该结点之间的路径长度与该结点的权的乘积。</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/23.png" srcset="/img/loading.gif" alt="结点的带权路径长度" style="zoom:80%;">

<h4 id="1-3-树的带权路径长度"><a href="#1-3-树的带权路径长度" class="headerlink" title="1.3 树的带权路径长度"></a>1.3 树的带权路径长度</h4><p><strong>树的带权路径长度为</strong>：树中所有叶子节点的带权路径长度之和，一般称为WPL，权值越大的结点离根结点越近的二叉树才是最优二叉树。</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/24.png" srcset="/img/loading.gif" alt="树的带权路径长度" style="zoom:80%;">

<h4 id="1-4-赫夫曼树"><a href="#1-4-赫夫曼树" class="headerlink" title="1.4 赫夫曼树"></a>1.4 赫夫曼树</h4><p>假设有n个权值{w1,w2,…,wn}，试构造一棵<strong>有n个叶子结点的二叉树</strong>，其中带权路径长度WPL最小的二叉树称为<strong>最优二叉树</strong>或<strong>赫夫曼树</strong>。</p>
<h3 id="2-构造赫夫曼树"><a href="#2-构造赫夫曼树" class="headerlink" title="2. 构造赫夫曼树"></a>2. 构造赫夫曼树</h3><h4 id="2-1-要求"><a href="#2-1-要求" class="headerlink" title="2.1 要求"></a>2.1 要求</h4><p>给定权值数列：{6, 3, 8, 2, 9}，要求构造赫夫曼树。</p>
<h4 id="2-2-赫夫曼算法"><a href="#2-2-赫夫曼算法" class="headerlink" title="2.2 赫夫曼算法"></a>2.2 赫夫曼算法</h4><ol>
<li>从小到大排序，每个数据都是一个结点，每一个结点可以看成一棵最简单的二叉树</li>
<li>取出根节点权值最小的两棵二叉树</li>
<li>组成一棵新的二叉树，该新的二叉树的根结点的权值是前面两棵二叉树根结点权值的和</li>
<li>再将这颗新的二叉树，以根结点的权值大小再次排序，不断重复1-2-3-4的步骤</li>
<li>直到权值数列中所有的数据都被处理，就得到了一棵赫夫曼树</li>
</ol>
<h4 id="2-3-图解"><a href="#2-3-图解" class="headerlink" title="2.3 图解"></a>2.3 图解</h4><p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/25.png" srcset="/img/loading.gif" alt="赫夫曼树构建"></p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/26.png" srcset="/img/loading.gif" alt="赫夫曼树构建">

<p>在计算<code>带权路径长度</code>的时候，需要<code>重新计算树的高度</code>(从下往上)，因为哈夫曼树是从下往上构造的，所以对于高度不太好维护，可以构造好然后计算高度。</p>
<p>比如上述的<code>WPL</code>为：<code>2*3+3*3+6*2+8*2+9*2=(2+3)*3+(6+8+9)*2=61</code>.</p>
<h4 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h4><p><strong>结点类Node</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 结点类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Node</span>&gt;</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;<br>    <span class="hljs-keyword">public</span> Node left;<br>    <span class="hljs-keyword">public</span> Node right;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *记录结点深度</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> depth;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 前序遍历</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.left.preOrder();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.right.preOrder();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;value=&quot;</span> + value +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Node o)</span> </span>&#123;<br>        <span class="hljs-comment">// 表示从小到大排序</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value - o.value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>创建赫夫曼树</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建赫夫曼树</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">createHuffmanTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br><br>    List&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> ArrayList&lt;Node&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value: arr) &#123;<br>        nodes.add(<span class="hljs-keyword">new</span> Node(value));<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (nodes.size() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 从小到大排序</span><br>        Collections.sort(nodes);<br><br>        <span class="hljs-comment">// 取出根节点最小的两课二叉树</span><br>        Node leftNode = nodes.get(<span class="hljs-number">0</span>);<br>        Node rightNode = nodes.get(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 构建一棵新的二叉树</span><br>        Node parent = <span class="hljs-keyword">new</span> Node(leftNode.value + rightNode.value);<br>        parent.left = leftNode;<br>        parent.right = rightNode;<br><br>        <span class="hljs-comment">// 删除处理过的二叉树</span><br>        nodes.remove(leftNode);<br>        nodes.remove(rightNode);<br><br>        <span class="hljs-comment">// 将parent二叉树加入</span><br>        nodes.add(parent);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>求赫夫曼树带权路径长度</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取赫夫曼树的带权路径长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWPL</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    ArrayDeque&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    nodes.add(root);<br>    <span class="hljs-keyword">int</span> WPL = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!nodes.isEmpty()) &#123;<br>        Node node = nodes.poll();<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span> &amp;&amp; node.right != <span class="hljs-keyword">null</span>) &#123;<br>            node.left.depth = node.depth + <span class="hljs-number">1</span>;<br>            node.right.depth = node.depth + <span class="hljs-number">1</span>;<br>            nodes.add(node.left);<br>            nodes.add(node.right);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            WPL += node.depth * node.value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> WPL;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>整合代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Aatrox</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 赫夫曼树</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-02-21 19:22</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanTree</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>&#125;;<br>    Node root = createHuffmanTree(arr);<br>    preOrder(root);<br>    <span class="hljs-keyword">int</span> wpl = getWPL(root);<br>    System.out.println(<span class="hljs-string">&quot;赫夫曼树带权路径长度为：&quot;</span>+ wpl);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 先序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>      root.preOrder();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;空树，无法遍历&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建赫夫曼树</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">createHuffmanTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br><br>    List&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> ArrayList&lt;Node&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value: arr) &#123;<br>      nodes.add(<span class="hljs-keyword">new</span> Node(value));<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (nodes.size() &gt; <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">// 从小到大排序</span><br>      Collections.sort(nodes);<br><br>      <span class="hljs-comment">// 取出根节点最小的两课二叉树</span><br>      Node leftNode = nodes.get(<span class="hljs-number">0</span>);<br>      Node rightNode = nodes.get(<span class="hljs-number">1</span>);<br><br>      <span class="hljs-comment">// 构建一棵新的二叉树</span><br>      Node parent = <span class="hljs-keyword">new</span> Node(leftNode.value + rightNode.value);<br>      parent.left = leftNode;<br>      parent.right = rightNode;<br><br>      <span class="hljs-comment">// 删除处理过的二叉树</span><br>      nodes.remove(leftNode);<br>      nodes.remove(rightNode);<br><br>      <span class="hljs-comment">// 将parent二叉树加入</span><br>      nodes.add(parent);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取赫夫曼树的带权路径长度</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWPL</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    ArrayDeque&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    nodes.add(root);<br>    <span class="hljs-keyword">int</span> WPL = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!nodes.isEmpty()) &#123;<br>      Node node = nodes.poll();<br>      <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span> &amp;&amp; node.right != <span class="hljs-keyword">null</span>) &#123;<br>        node.left.depth = node.depth + <span class="hljs-number">1</span>;<br>        node.right.depth = node.depth + <span class="hljs-number">1</span>;<br>        nodes.add(node.left);<br>        nodes.add(node.right);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        WPL += node.depth * node.value;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> WPL;<br><br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 结点类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Node</span>&gt;</span>&#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;<br>  <span class="hljs-keyword">public</span> Node left;<br>  <span class="hljs-keyword">public</span> Node right;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   *记录结点深度</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> depth;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.value = value;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 前序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.left.preOrder();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.right.preOrder();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;value=&quot;</span> + value +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br><br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Node o)</span> </span>&#123;<br>    <span class="hljs-comment">// 表示从小到大排序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value - o.value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&#123;value=<span class="hljs-number">28</span>&#125;<br>Node&#123;value=<span class="hljs-number">11</span>&#125;<br>Node&#123;value=<span class="hljs-number">5</span>&#125;<br>Node&#123;value=<span class="hljs-number">2</span>&#125;<br>Node&#123;value=<span class="hljs-number">3</span>&#125;<br>Node&#123;value=<span class="hljs-number">6</span>&#125;<br>Node&#123;value=<span class="hljs-number">17</span>&#125;<br>Node&#123;value=<span class="hljs-number">8</span>&#125;<br>Node&#123;value=<span class="hljs-number">9</span>&#125;<br>赫夫曼树带权路径长度为：<span class="hljs-number">61</span><br></code></pre></td></tr></table></figure>



<h3 id="3-赫夫曼编码"><a href="#3-赫夫曼编码" class="headerlink" title="3.赫夫曼编码"></a>3.赫夫曼编码</h3><h4 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1 基本介绍"></a>3.1 基本介绍</h4><ol>
<li>赫夫曼编码是一种编码方式，属于一种程序算法</li>
<li>赫夫曼编码是赫夫曼树在电讯通信中的经典的应用之一</li>
<li>赫夫曼编码广泛地用于数据文件压缩，其压缩率通常在20%~90%之间</li>
<li>赫夫曼编码是可变字长编码的一种，也称为最佳编码</li>
</ol>
<h4 id="3-2-原理剖析"><a href="#3-2-原理剖析" class="headerlink" title="3.2 原理剖析"></a>3.2 原理剖析</h4><p>在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。</p>
<p>现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。若报文中可能出现26个不同字符，则固定编码长度为5</p>
<p>然而，传送报文时总是希望总长度尽可能短。在实际应用中，各个字符的出现频度或使用次数是不相同的，如A、B、C的使用频率远远高于X、Y、Z，自然会想到设计编码时，让<strong>使用频率高的用短码，使用频率低的用长码</strong>，以优化整个报文编码</p>
<p>为使不等长编码为<strong>前缀编码</strong>(即要求一个字符的编码不能是另一个字符编码的前缀)，可用字符集中的每个字符作为叶子结点生成一棵编码二叉树，为了获得传送报文的最短长度，可将每个字符的出现频率作为字符结点的权值赋予该结点上，显然字使用频率越小权值越小，权值越小叶子就越靠下，于是频率小编码长，频率高编码短，这样就保证了此树的最小带权路径长度效果上就是传送报文的最短长度。</p>
<p>因此，求传送报文的最短长度问题转化为求由字符集中的所有字符作为叶子结点，由字符出现频率作为其权值所产生的哈夫曼树的问题。利用哈夫曼树来设计二进制的前缀编码，既满足前缀编码的条件，又保证报文编码总长最短，该前缀编码称为<strong>赫夫曼编码</strong></p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/27.png" srcset="/img/loading.gif" alt="赫夫曼编码" style="zoom: 67%;">

<p>如上图所示，对于一个字符串“AAAAABCCCCCCDDD” 来说，很容易知道每个字符出现的频次{5，1，6，3}。根据频次，每次选出频次最小的两个结点进行组合，频次相加得到父结点。不断重复此过程，直到产生一颗哈夫曼树。</p>
<p>通过该哈夫曼树，我们可以得到每个字符的哈夫曼编码 A=11，B=100,C=0,D=101</p>
<h4 id="3-3-题目案例"><a href="#3-3-题目案例" class="headerlink" title="3.3 题目案例"></a>3.3 题目案例</h4><p>将给出的一段文本，比如：“I like like like java do u like java”，根据赫夫曼编码原理，对其进行数据压缩处理，压缩后能够进行解压。</p>
<h4 id="3-4-代码实现-1"><a href="#3-4-代码实现-1" class="headerlink" title="3.4 代码实现"></a>3.4 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Aatrox</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 赫夫曼编码压缩</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-02-21 22:27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanCode</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-string">&quot;i like like like java do u like java&quot;</span>;<br>    <span class="hljs-keyword">byte</span>[] contentBytes = str.getBytes();<br>    System.out.println(<span class="hljs-string">&quot;压缩前的结果：&quot;</span> + Arrays.toString(contentBytes) + <span class="hljs-string">&quot;；长度为：&quot;</span> + contentBytes.length);<br>    <span class="hljs-keyword">byte</span>[] huffmanCodeBytes = huffmanZip(contentBytes);<br>    System.out.println(<span class="hljs-string">&quot;压缩后的结果：&quot;</span> + Arrays.toString(huffmanCodeBytes) + <span class="hljs-string">&quot;；长度为：&quot;</span> + huffmanCodeBytes.length);<br>    <span class="hljs-keyword">byte</span>[] sourceBytes = decode(huffmanCodes, huffmanCodeBytes);<br>    System.out.println(<span class="hljs-string">&quot;解压后的字符串=&quot;</span>+ <span class="hljs-keyword">new</span> String(sourceBytes));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取字符出现次数列表</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> bytes 接收字符数组</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 返回</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Node&gt; <span class="hljs-title">getNodes</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>    ArrayList&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-comment">// 统计每一个byte出现次数</span><br>    HashMap&lt;Byte, Integer&gt; counts = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> b: bytes) &#123;<br>      Integer count = counts.get(b);<br>      <span class="hljs-comment">// 第一次出现</span><br>      <span class="hljs-keyword">if</span> (count == <span class="hljs-keyword">null</span>) &#123;<br>        counts.put(b, <span class="hljs-number">1</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        counts.put(b, count + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 把每一个键值对转成 Node 对象，并加入nodes集合</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry: counts.entrySet()) &#123;<br>      nodes.add(<span class="hljs-keyword">new</span> Node(entry.getKey(), entry.getValue()));<br>    &#125;<br>    <span class="hljs-keyword">return</span> nodes;<br><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 通过List创建赫夫曼树</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">createHuffmanTree</span><span class="hljs-params">(List&lt;Node&gt; nodes)</span> </span>&#123;<br><br>    <span class="hljs-keyword">while</span> (nodes.size() &gt;<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">// 从小到大排序</span><br>      Collections.sort(nodes);<br>      <span class="hljs-comment">// 取出前两棵最小二叉树</span><br>      Node leftNode = nodes.get(<span class="hljs-number">0</span>);<br>      Node rightNode = nodes.get(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// 创建一棵新的二叉树,合并的新结点没有数据，只有权值</span><br>      Node parentNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-keyword">null</span>, leftNode.weight + rightNode.weight);<br>      parentNode.left = leftNode;<br>      parentNode.right = rightNode;<br>      <span class="hljs-comment">// 将已经处理的两棵二叉树从nodes移除</span><br>      nodes.remove(leftNode);<br>      nodes.remove(rightNode);<br>      <span class="hljs-comment">//加入新的二叉树</span><br>      nodes.add(parentNode);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 先序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>      root.preOrder();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;赫夫曼树为空&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生成赫夫曼树对应的赫夫曼编码：Map&lt;Byte, String&gt;，如&lt;97, &quot;100&quot;&gt;，即a字符对应的编码为100</span><br><span class="hljs-comment">   * StringBuilder 用于根据路径拼接赫夫曼编码</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="hljs-keyword">new</span> HashMap&lt;Byte, String&gt;();<br>  <span class="hljs-keyword">static</span> StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 得到赫夫曼编码</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> node 传入结点</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> code 路径码：左子结点是0，右子节点为1</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> stringBuilder 拼接路径</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getHuffmanCodes</span><span class="hljs-params">(Node node, String code, StringBuilder stringBuilder)</span> </span>&#123;<br><br>    StringBuilder stringBuilder2 = <span class="hljs-keyword">new</span> StringBuilder(stringBuilder);<br>    <span class="hljs-comment">// 将 code 路径码加入stringBuilder2</span><br>    stringBuilder2.append(code);<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">// 判断 node 是叶子结点还是非叶子节点</span><br>      <span class="hljs-keyword">if</span> (node.data == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 向左递归</span><br>        getHuffmanCodes(node.left, <span class="hljs-string">&quot;0&quot;</span>, stringBuilder2);<br>        <span class="hljs-comment">// 向右递归</span><br>        getHuffmanCodes(node.right, <span class="hljs-string">&quot;1&quot;</span>, stringBuilder2);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        huffmanCodes.put(node.data, stringBuilder2.toString());<br>      &#125;<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 重载getCodes</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;Byte, String&gt; <span class="hljs-title">getHuffmanCodes</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      getHuffmanCodes(root.left, <span class="hljs-string">&quot;0&quot;</span>, stringBuilder);<br>      getHuffmanCodes(root.right, <span class="hljs-string">&quot;1&quot;</span>, stringBuilder);<br>      <span class="hljs-keyword">return</span> huffmanCodes;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 将字符串对应的byte[]数组，通过赫夫曼编码Map，返回赫夫曼编码压缩后的 byte[]数组</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> bytes 原始字符串对应的byte数组</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> huffmanCodes 生成的赫夫曼编码</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 返回赫夫曼编码压缩后的byte数组</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] zip(<span class="hljs-keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;<br><br>    StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> b: bytes) &#123;<br>      stringBuilder.append(huffmanCodes.get(b));<br>    &#125;<br><br>    <span class="hljs-comment">// 统计需要返回的byte数组长度</span><br>    <span class="hljs-keyword">int</span> len;<br>    <span class="hljs-keyword">if</span> (stringBuilder.length() % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>      len = stringBuilder.length() / <span class="hljs-number">8</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      len = stringBuilder.length() / <span class="hljs-number">8</span> + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建存储压缩后的byte数组</span><br>    <span class="hljs-keyword">byte</span>[] huffmanCodeBytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[len];<br>    <span class="hljs-comment">// huffmanCodeBytes数组索引</span><br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 每8位对应一个byte</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stringBuilder.length(); i += <span class="hljs-number">8</span>, index++) &#123;<br>      String strByte;<br>      <span class="hljs-comment">// 如果最后不够8位,取到最后即可</span><br>      <span class="hljs-keyword">if</span> (i + <span class="hljs-number">8</span> &gt; stringBuilder.length()) &#123;<br>        strByte = stringBuilder.substring(i);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        strByte = stringBuilder.substring(i, i + <span class="hljs-number">8</span>);<br>      &#125;<br>      <span class="hljs-comment">// 将strByte转成byte数组</span><br>      huffmanCodeBytes[index] = (<span class="hljs-keyword">byte</span>) Integer.parseInt(strByte, <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> huffmanCodeBytes;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 封装前面的方法</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> bytes 原始的字符串对应的字节数组</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 经过赫夫曼编码压缩后的字节数组</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] huffmanZip(<span class="hljs-keyword">byte</span>[] bytes) &#123;<br>    List&lt;Node&gt; nodes = getNodes(bytes);<br>    <span class="hljs-comment">// 根据nodes创建赫夫曼树</span><br>    Node huffmanTreeRoot = createHuffmanTree(nodes);<br>    <span class="hljs-comment">// 根据赫夫曼树生成赫夫曼编码</span><br>    Map&lt;Byte, String&gt; huffmanCodes = getHuffmanCodes(huffmanTreeRoot);<br>    <span class="hljs-comment">// 根据赫夫曼编码得到压缩后的字节数组</span><br>    <span class="hljs-keyword">return</span> zip(bytes, huffmanCodes);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 将一个byte转化为一个二进制的字符串</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">byteToBitString</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag, <span class="hljs-keyword">byte</span> b)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 返回 b 对应的二进制的补码</span><br>    <span class="hljs-keyword">int</span> temp = b;<br>    <span class="hljs-comment">// 标志是否需要取高位</span><br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>      temp |= <span class="hljs-number">256</span>;<br>    &#125;<br>    String str = Integer.toBinaryString(temp);<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>      <span class="hljs-keyword">return</span> str.substring(str.length() - <span class="hljs-number">8</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> str;<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   *  对压缩数据解码</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> huffmanCodes 赫夫曼编码表</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> huffmanBytes 赫夫曼得到的字节数组</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 原来的字符串对应的byte数组</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="hljs-keyword">byte</span>[] huffmanBytes) &#123;<br><br>    <span class="hljs-comment">// 先得到 huffmanBytes 对应的二进制的字符串</span><br>    StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-comment">// 将 byte 数组转成二进制字符串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; huffmanBytes.length; i++) &#123;<br>      <span class="hljs-keyword">byte</span> b = huffmanBytes[i];<br>      <span class="hljs-keyword">boolean</span> flag = (i == huffmanBytes.length - <span class="hljs-number">1</span>);<br>      stringBuilder.append(byteToBitString(!flag, b));<br>    &#125;<br><br>    <span class="hljs-comment">// 把字符串按照指定的赫夫曼编码进行解码</span><br>    Map&lt;String, Byte&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Byte&gt;();<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry: huffmanCodes.entrySet()) &#123;<br>      map.put(entry.getValue(), entry.getKey());<br>    &#125;<br><br>    <span class="hljs-comment">// 创建要给集合，存放byte</span><br>    List&lt;Byte&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stringBuilder.length();) &#123;<br>      <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>      Byte b = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">while</span> (flag) &#123;<br>        <span class="hljs-comment">// 取字符直到能取出Map中存在的编码</span><br>        String key = stringBuilder.substring(i, i + count);<br>        b = map.get(key);<br>        <span class="hljs-comment">// 尚未匹配到</span><br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>) &#123;<br>          count++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          flag = <span class="hljs-keyword">false</span>;<br>        &#125;<br>      &#125;<br>      list.add(b);<br>      i += count;<br>    &#125;<br><br>    <span class="hljs-comment">// 把list中的数据放入byte[] 并返回</span><br>    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[list.size()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; b.length; i++) &#123;<br>      b[i] = list.get(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 结点类，存放数据和权值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Node</span>&gt;</span>&#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 存放数据（字符）本身，比如&#x27;a&#x27; =&gt; 97</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Byte data;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 权值，表示字符出现的次数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> weight;<br><br>  <span class="hljs-keyword">public</span> Node left, right;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Byte data, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.data = data;<br>    <span class="hljs-keyword">this</span>.weight = weight;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Node o)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.weight - o.weight;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;data=&quot;</span> + data +<br>            <span class="hljs-string">&quot;, weight=&quot;</span> + weight +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 前序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.left.preOrder();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.right.preOrder();<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-5-测试结果"><a href="#3-5-测试结果" class="headerlink" title="3.5 测试结果"></a>3.5 测试结果</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">压缩前的结果：[105, 32, 108, 105, 107, 101, 32, 108, 105, 107, 101, 32, 108, 105, 107, 101, 32, 106, 97, 118, 97, 32, 100, 111, 32, 117, 32, 108, 105, 107, 101, 32, 106, 97, 118, 97]；长度为：36<br>压缩后的结果：[-60, -51, 19, 52, 76, -47, 95, -33, 45, -62, -28, -51, 21, -3, 15]；长度为：15<br>解压后的字符串=i like like like java <span class="hljs-keyword">do</span> u like java<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="六、二叉排序树（BST）"><a href="#六、二叉排序树（BST）" class="headerlink" title="六、二叉排序树（BST）"></a>六、二叉排序树（BST）</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>二叉排序树：BST：(Binary Sort(Search) Tree)，对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</p>
<p>说明：如果有相同的值，可以将该节点放在左子节点或右子节点。</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/28.png" srcset="/img/loading.gif" alt="二叉排序树" style="zoom:;">

<h3 id="2-创建二叉排序树"><a href="#2-创建二叉排序树" class="headerlink" title="2.创建二叉排序树"></a>2.创建二叉排序树</h3><h4 id="2-1-要求-1"><a href="#2-1-要求-1" class="headerlink" title="2.1 要求"></a>2.1 要求</h4><p>一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如：数组为Array{7, 3, 10, 12, 5, 1, 9}，创建成对应的二叉排序树为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/29.png" srcset="/img/loading.gif" alt="二叉排序树"></p>
<p>中序遍历应为：1、3、5、7、9、10、12</p>
<h4 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Aatrox</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 二叉排序树</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-02-23 11:28</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySortTree</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> Node root;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 添加结点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>      root = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      root.add(node);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 中序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>      root.inOrder();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;二叉排序树为空，不能遍历&quot;</span>);<br>    &#125;<br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 结点类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;<br>  <span class="hljs-keyword">public</span> Node left;<br>  <span class="hljs-keyword">public</span> Node right;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.value = value;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;value=&quot;</span> + value +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 添加结点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判断传入的值与当前子树根节点的关系</span><br>    <span class="hljs-keyword">if</span> (node.value &lt; <span class="hljs-keyword">this</span>.value) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.left = node;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.left.add(node);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.right = node;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.right.add(node);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 中序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.left.inOrder();<br>    &#125;<br>    System.out.println(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.right.inOrder();<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>&#125;;<br>    BinarySortTree binarySortTree = <span class="hljs-keyword">new</span> BinarySortTree();<br>    <span class="hljs-comment">// 循环添加结点到二叉排序树</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>      binarySortTree.add(<span class="hljs-keyword">new</span> Node(arr[i]));<br>    &#125;<br>    <span class="hljs-comment">// 中序遍历二叉排序树</span><br>    binarySortTree.inOrder();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Node&#123;value=1&#125;<br>Node&#123;value=3&#125;<br>Node&#123;value=5&#125;<br>Node&#123;value=7&#125;<br>Node&#123;value=9&#125;<br>Node&#123;value=10&#125;<br>Node&#123;value=12&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-二叉排序树的删除"><a href="#3-二叉排序树的删除" class="headerlink" title="3. 二叉排序树的删除"></a>3. 二叉排序树的删除</h3><h4 id="3-1-分析情况"><a href="#3-1-分析情况" class="headerlink" title="3.1 分析情况"></a>3.1 分析情况</h4><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑:</p>
<p><strong>情况1</strong>：删除叶子结点</p>
<p><strong>情况2</strong>：删除只有一棵子树的结点</p>
<p><strong>情况3</strong>：删除有两棵子树的结点</p>
<h4 id="3-2思路分析"><a href="#3-2思路分析" class="headerlink" title="3.2思路分析"></a>3.2思路分析</h4><p><strong>删除叶子结点</strong>：</p>
<ul>
<li><p>需要先去找到要删除的结点 targetNode</p>
</li>
<li><p>找到 targetValue 的父结点 parent</p>
</li>
<li><p>确定 targetNode 是 parent 的左子结点还是右子结点</p>
</li>
<li><p>根据前面的情况来对应删除</p>
<p>左子结点：parent.left = null;</p>
<p>右子结点：parent.right = null;</p>
</li>
</ul>
<p><strong>删除只有一棵子树的结点</strong>：</p>
<ul>
<li><p>需要先去找到要删除的结点 targetNode</p>
</li>
<li><p>找到 targetValue 的父结点 parent</p>
</li>
<li><p>确定 targetNode 的唯一一个子结点是左子结点还是右子结点</p>
</li>
<li><p>确定 targetNode 是 parent 的左子结点还是右子结点</p>
</li>
<li><p>如果 targetNode 有左子结点，且 targetNode 是 parent 左子结点：parent.left = targetNode.left;</p>
<p>如果 targetNode 有左子结点，且 targetNode 是 parent 右子结点：parent.right = targetNode.left;</p>
<p>如果 targetNode 有右子结点，且 targetNode 是 parent 左子结点：parent.left= targetNode.right;</p>
<p>如果 targetNode 有右子结点，且 targetNode 是 parent 右子结点：parent.right = targetNode.right</p>
</li>
</ul>
<p><strong>删除有两棵子树的结点</strong></p>
<ul>
<li>需要先去找到要删除的结点 targetNode</li>
<li>找到 targetValue 的父结点 parent</li>
<li>从 targetNode 的右子树（左子树）找到最小（最大）的结点</li>
<li>用一个临时变量，将最小（最大）结点的值保存 temp</li>
<li>删除该最小（最大）结点</li>
<li>令 targetNode.value = temp</li>
</ul>
<h4 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3 代码"></a>3.3 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Aatrox</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 二叉排序树</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-02-23 11:28</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySortTree</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> Node root;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 添加结点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>      root = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      root.add(node);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 查找要删除的结点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">searchBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> root.searchBST(value);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 查找要删除结点的父结点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">searchParent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> root.searchParent(value);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 中序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>      root.inOrder();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;二叉排序树为空，不能遍历&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 删除某结点右子树最小的结点值，并返回该最小值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> node 传入的结点（当作二叉排序树的根结点）</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 以node为根节点的二叉排序树的最小结点的值</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">delRightTreeMin</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">// target保存右子树最小结点</span><br>    Node target = node;<br>    <span class="hljs-keyword">while</span> (target.left != <span class="hljs-keyword">null</span>) &#123;<br>      target = target.left;<br>    &#125;<br>    <span class="hljs-comment">//删除最小结点</span><br>    delNode(target.value);<br>    <span class="hljs-keyword">return</span> target.value;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 删除结点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 1.找到要删除的结点</span><br>      Node targetNode = searchBST(value);<br>      <span class="hljs-keyword">if</span> (targetNode == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">// 如果我们发现当前二叉排序树只有一个结点</span><br>      <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>        root = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 2.找到 targetNode 的父结点</span><br>      Node parent = searchParent(value);<br>      <span class="hljs-comment">// 如果要删除的结点是叶子结点</span><br>      <span class="hljs-keyword">if</span> (targetNode.left == <span class="hljs-keyword">null</span> &amp;&amp; targetNode.right == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 判断targetNode 是父节点的左子结点还是右子结点</span><br>        <span class="hljs-keyword">if</span> (parent.left != <span class="hljs-keyword">null</span> &amp;&amp; parent.left.value == value) &#123;<br>          parent.left = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent.right != <span class="hljs-keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<br>          parent.right = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果要删除的结点为只有一棵子树的结点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetNode.left != <span class="hljs-keyword">null</span> &amp;&amp; targetNode.right != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">int</span> minVal = delRightTreeMin(targetNode.right);<br>        targetNode.value = minVal;<br>        <span class="hljs-comment">// 如果要删除的结点为有两棵子树的结点</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (targetNode.left != <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (parent.left != <span class="hljs-keyword">null</span> &amp;&amp; parent.left.value == value) &#123;<br>              parent.left = targetNode.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              parent.right = targetNode.left;<br>            &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            root = targetNode.left;<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (parent.left != <span class="hljs-keyword">null</span> &amp;&amp; parent.left.value == value) &#123;<br>              parent.left = targetNode.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              parent.right = targetNode.right;<br>            &#125;<br>          &#125;<span class="hljs-keyword">else</span> &#123;<br>            root = targetNode.right;<br>          &#125;<br>        &#125;<br>      &#125;<br><br>    &#125;<br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 结点类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;<br>  <span class="hljs-keyword">public</span> Node left;<br>  <span class="hljs-keyword">public</span> Node right;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.value = value;<br>  &#125;<br><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 查找要删除的结点</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value 希望删除的结点值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 找到返回该节点，没找到返回null</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">searchBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.value == value) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>      <span class="hljs-comment">// 小于此节点值，向左子树查找</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-keyword">this</span>.value) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.left.searchBST(value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.right.searchBST(value);<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 查找要删除结点的父结点</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value 希望删除的结点值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 返回要删除结点的父结点，没有就返回null</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">searchParent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果当前结点就是要删除结点的父结点</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.left.value == value) || (<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.right.value == value)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 向左子树递归查找</span><br>      <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-keyword">this</span>.value &amp;&amp; <span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.left.searchParent(value);<br>        <span class="hljs-comment">// 向右子树递归查找</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-keyword">this</span>.value &amp;&amp; <span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.right.searchParent(value);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;value=&quot;</span> + value +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 添加结点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判断传入的值与当前子树根节点的关系</span><br>    <span class="hljs-keyword">if</span> (node.value &lt; <span class="hljs-keyword">this</span>.value) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.left = node;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.left.add(node);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.right = node;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.right.add(node);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 中序遍历</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.left.inOrder();<br>    &#125;<br>    System.out.println(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.right.inOrder();<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>&#125;;<br>    BinarySortTree binarySortTree = <span class="hljs-keyword">new</span> BinarySortTree();<br>    <span class="hljs-comment">// 循环添加结点到二叉排序树</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>      binarySortTree.add(<span class="hljs-keyword">new</span> Node(arr[i]));<br>    &#125;<br>    <span class="hljs-comment">// 中序遍历二叉排序树</span><br>    binarySortTree.inOrder();<br><span class="hljs-comment">//    binarySortTree.delNode(1);</span><br><span class="hljs-comment">//    binarySortTree.delNode(5);</span><br><span class="hljs-comment">//    binarySortTree.delNode(9);</span><br><span class="hljs-comment">//    binarySortTree.delNode(7);</span><br>    System.out.println(<span class="hljs-string">&quot;删除节点后&quot;</span>);<br>    binarySortTree.inOrder();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="七、平衡二叉树（AVL）"><a href="#七、平衡二叉树（AVL）" class="headerlink" title="七、平衡二叉树（AVL）"></a>七、平衡二叉树（AVL）</h2><h3 id="1-为什么需要AVL"><a href="#1-为什么需要AVL" class="headerlink" title="1.为什么需要AVL"></a>1.为什么需要AVL</h3><p>给一个数列{1, 2, 3, 4, 5, 6,}，要求创建一棵二叉排序树，分析问题所在。</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/30.png" srcset="/img/loading.gif" alt="BST" style="zoom: 50%;">

<p><strong>建立的BST存在的问题分析</strong>：</p>
<ol>
<li>左子树全为空，从形式上看，更像一个单链表。</li>
<li>插入速度没有影响</li>
<li>查询速度明显降低（因为需要依次比较），不能发挥BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢。</li>
<li>解决方案：<strong>平衡二叉树（AVL）</strong></li>
</ol>
<h3 id="2-基本介绍"><a href="#2-基本介绍" class="headerlink" title="2.基本介绍"></a>2.基本介绍</h3><ul>
<li>平衡二叉树也叫平衡二叉搜索树（self-balancing binary search tree），又被称为AVL树，可以保证查询效率较高。</li>
<li>AVL树有以下特点：它是一棵空树或它的<strong>左右两个子树的高度差的绝对值不超过1</strong>，并且<strong>左右两个子树都是一棵平衡二叉树</strong>。平衡二叉树的常用实现方法：<strong>红黑树</strong>、<strong>AVL</strong>、<strong>替罪羊树</strong>、<strong>Treap</strong>、<strong>伸展树</strong>等。</li>
<li>AVL树必定是二叉排序树。</li>
</ul>
<h3 id="3-左旋转-LL型"><a href="#3-左旋转-LL型" class="headerlink" title="3. 左旋转(LL型)"></a>3. 左旋转(LL型)</h3><h4 id="3-1-思路"><a href="#3-1-思路" class="headerlink" title="3.1 思路"></a>3.1 思路</h4><p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/31.png" srcset="/img/loading.gif" alt="3"></p>
<h4 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2 代码"></a>3.2 代码</h4><p><strong>在Node结点类增加获取获取左右子树高度的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回当前结点的高度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 高度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Math.max(left == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> :left.height(), right == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : right.height()) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回左子树高度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 高度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leftHeight</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left.height();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回右子树高度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 高度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rightHeight</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right.height();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>左旋转方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 左旋转方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftRotate</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 创建新的结点，值为根节点值</span><br>    Node newNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-keyword">this</span>.value);<br>    <span class="hljs-comment">// 把新的结点的左子树设为当前结点的左子树</span><br>    newNode.left = <span class="hljs-keyword">this</span>.left;<br>    <span class="hljs-comment">// 把新的结点的右子树设为当前结点的右子树的左子树</span><br>    newNode.right = <span class="hljs-keyword">this</span>.right.left;<br>    <span class="hljs-comment">// 把当前结点的值替换成右子结点的值</span><br>    <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.right.value;<br>    <span class="hljs-comment">// 把当前结点的右子树设为右子树的右子树</span><br>    <span class="hljs-keyword">this</span>.right = <span class="hljs-keyword">this</span>.right.right;<br>    <span class="hljs-comment">// 把当前结点的左子树设置为新的结点</span><br>    <span class="hljs-keyword">this</span>.left = newNode;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-右旋转-RR型"><a href="#4-右旋转-RR型" class="headerlink" title="4. 右旋转(RR型)"></a>4. 右旋转(RR型)</h3><h4 id="4-1-思路"><a href="#4-1-思路" class="headerlink" title="4.1 思路"></a>4.1 思路</h4><p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/32.png" srcset="/img/loading.gif" alt="右旋转思路"></p>
<h4 id="4-2-代码"><a href="#4-2-代码" class="headerlink" title="4.2 代码"></a>4.2 代码</h4><p><strong>右旋转方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 右旋转方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightRotate</span><span class="hljs-params">()</span> </span>&#123;<br><br>    Node newNode = <span class="hljs-keyword">new</span> Node(value);<br>    newNode.right = right;<br>    newNode.left = left.right;<br>    value = left.value;<br>    left = left.left;<br>    right = newNode;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-双旋转-LR-RL型"><a href="#5-双旋转-LR-RL型" class="headerlink" title="5.双旋转(LR/RL型)"></a>5.双旋转(LR/RL型)</h3><h4 id="5-1-问题分析"><a href="#5-1-问题分析" class="headerlink" title="5.1 问题分析"></a>5.1 问题分析</h4><p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/33.png" srcset="/img/loading.gif" alt="问题"></p>
<ol>
<li><p>当符合右旋转的条件时</p>
</li>
<li><p>如果它的左子树的右子树高度大于它的右子树的高度</p>
</li>
<li><p>先对当前这个结点的左结点进行左旋转</p>
</li>
<li><p>再对当前结点进行右旋转的操作即可</p>
</li>
</ol>
<p>反之，</p>
<ol>
<li>当符合左旋转的条件</li>
<li>如果它的右子树的左子树高度大于它的左子树的高度、</li>
<li>先对当前这个结点的右结点进行右旋转</li>
<li>再对当前结点进行左旋转的操作即可</li>
</ol>
<h4 id="5-2-思路图解"><a href="#5-2-思路图解" class="headerlink" title="5.2  思路图解"></a>5.2  思路图解</h4><p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/34.png" srcset="/img/loading.gif" alt="图解"></p>
<h3 id="6-添加结点时结合情况旋转"><a href="#6-添加结点时结合情况旋转" class="headerlink" title="6. 添加结点时结合情况旋转"></a>6. 添加结点时结合情况旋转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加结点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判断传入的值与当前子树根节点的关系</span><br>    <span class="hljs-keyword">if</span> (node.value &lt; <span class="hljs-keyword">this</span>.value) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.left = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.left.add(node);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.right = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.right.add(node);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 当添加完一个节点后，如果右子树高度比左子树高度大于1，左旋转</span><br>    <span class="hljs-keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (right != <span class="hljs-keyword">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;<br>            right.rightRotate();<br>            leftRotate();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            leftRotate();<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 当添加完一个节点后，如果左子树高度比右子树高度大于1，右旋转</span><br>    <span class="hljs-keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// 如果它的左子树的右子树高度大于它的左子树高度</span><br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span> &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;<br>            <span class="hljs-comment">// 先对当前结点的左结点进行左旋转</span><br>            left.leftRotate();<br>            <span class="hljs-comment">// 在对当前结点进行右旋转</span><br>            rightRotate();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rightRotate();<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h2 id="八、多路查找树"><a href="#八、多路查找树" class="headerlink" title="八、多路查找树"></a>八、多路查找树</h2><h3 id="1-二叉树与B树"><a href="#1-二叉树与B树" class="headerlink" title="1.二叉树与B树"></a>1.二叉树与B树</h3><h4 id="1-1-二叉树"><a href="#1-1-二叉树" class="headerlink" title="1.1 二叉树"></a>1.1 二叉树</h4><p>二叉树的操作效率较高，但是也存在问题</p>
<ul>
<li>二叉树需要加载到内存，如果二叉树的结点少，没有什么问题，但是如果二叉树的结点很多，就存在以下问题</li>
<li>问题1：在构建二叉树时，需要多次进行IO操作（海量数据存储在数据库或文件中），结点海量，构建二叉树时，速度有影响。</li>
<li>问题2：结点海量，也会造成二叉树的高度很大，会降低操作速度。</li>
</ul>
<h4 id="1-2-多叉树"><a href="#1-2-多叉树" class="headerlink" title="1.2 多叉树"></a>1.2 多叉树</h4><ol>
<li><p>在二叉树中，每个结点有数据项，最多有两个子节点。如果允许每个结点可以有更多的数据项和更多的子结点，就是多叉树。</p>
</li>
<li><p>后面我们讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织结点，减少树的高度，能对二叉树进行优化。</p>
</li>
<li><p>举例说明（下面2-3就是一棵多叉树）</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/35.png" srcset="/img/loading.gif" alt="2-3树" style="zoom:80%;">

</li>
</ol>
<h4 id="1-3-B树"><a href="#1-3-B树" class="headerlink" title="1.3 B树"></a>1.3 B树</h4><p>B树通过重新组织结点，降低树的高度，并且减少IO读写次数来提升效率</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/13.jpg" srcset="/img/loading.gif" alt="B树" style="zoom:67%;">

<ol>
<li>如图B 树通过重新组织节点， 降低了树的高度。</li>
<li>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样所有节点只需要一次I/O 就可以完全载入。</li>
<li>将树的度M 设置为1024，在600 亿个元素中最多只需要4 次I/O 操作就可以读取到想要的元素, B 树(B+)广泛应用于文件存储系统以及数据库系统中。</li>
</ol>
<h3 id="2-2-3树"><a href="#2-2-3树" class="headerlink" title="2. 2-3树"></a>2. 2-3树</h3><h4 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h4><p>2-3树是最简单的B-树，具有如下特点：</p>
<ol>
<li>2-3树的所有叶子结点都在同一层。（只要是B树都满足这个条件）</li>
<li>有两个子结点的结点叫做二结点，二结点要么没有子结点，要么有两个子结点。</li>
<li>有三个子结点的结点叫做三结点，三结点要么没有子结点，要么有三个子结点。</li>
<li>2-3树是由二结点和三结点构成的树。</li>
</ol>
<h4 id="2-2-应用案例"><a href="#2-2-应用案例" class="headerlink" title="2.2 应用案例"></a>2.2 应用案例</h4><p>将数列{16,24,12,32,14,26,34,10,8,28,38,20}构建成2-3树，并保证数据插入的大小顺序。</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/14.jpg" srcset="/img/loading.gif" alt="构建2-3树" style="zoom: 67%;">

<p>插入规则：</p>
<ol>
<li>2-3树的所有叶子结点都在同一层（只要是B树都满足这个条件）</li>
<li>有两个子结点的结点叫做二结点，二结点要么没有子结点，要么有两个子结点。</li>
<li>有三个子结点的结点叫做三结点，三结点要么没有子结点，要么有三个子结点。</li>
<li>当按照规则插入一个数到某个节点时，不能满足上面三个要求，如果上层满，则拆本层，然后仍然需要满足上面3个条件。</li>
<li>对于三结点的子树的值大小仍然遵守二叉排序树的规则。</li>
</ol>
<h4 id="3-2-3-4树"><a href="#3-2-3-4树" class="headerlink" title="3. 2-3-4树"></a>3. 2-3-4树</h4><p>概念和2-3树类似。</p>
<h3 id="3-B树、B-树和B-树"><a href="#3-B树、B-树和B-树" class="headerlink" title="3. B树、B+树和B*树"></a>3. B树、B+树和B*树</h3><h4 id="3-1-基本介绍-1"><a href="#3-1-基本介绍-1" class="headerlink" title="3.1 基本介绍"></a>3.1 基本介绍</h4><p><strong>①B树</strong>：</p>
<p>B-tree树即为B树，B即为Balance，平衡的意思。有人把B-tree翻译成B-tree，容易让人产生误解。实际上B-tree就是指的B树。</p>
<p>前面介绍2-3树时，它们就是B树。这里我们做一个说明，我们在学习MySQL的时候，经常听到某种类型的索引时基于B树或B+树的，如图：</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/15.jpg" srcset="/img/loading.gif" alt="B树" style="zoom:50%;">

<p>B树的说明：</p>
<ol>
<li>B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4.</li>
<li>B树的搜索：从根节点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字的所属范围的儿子结点；重复，直到所对应的儿子指针为空，或者已经是叶子结点。</li>
<li>关键字集合分布在整棵树中，即叶子结点和非叶子结点都存放数据。</li>
<li>搜索有可能在非叶子结点结束。</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找。</li>
</ol>
<p><strong>②B+树</strong></p>
<p>B+树是B树的变体，也是一种多路搜索树。</p>
<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/数据结构：树/16.jpg" srcset="/img/loading.gif" alt="B+树" style="zoom: 80%;">

<p>B+树的说明：</p>
<ol>
<li>B+树的搜索与B树也基本相同，区别只是B+树只有达到叶子结点才命中，其性能也等价于在关键字全集做一次二分查找。</li>
<li>所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字恰好是有序的。</li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于叶子结点的索引（稀疏索引），叶子结点相当于是存储关键字的数据层</li>
<li>更适合文件索引系统</li>
<li>B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</li>
</ol>
<p>*<em>③B</em>树**</p>
<p>B*树是B+树的变体，在B+树的非根和非叶子结点增加指向兄弟的指针。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/36.png" srcset="/img/loading.gif" alt="B*树"></p>
<p>B*树的说明：</p>
<ol>
<li>B*树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3，而B+树的块的最低使用率为的1/2。</li>
<li>从第1 个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高。</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/DataStructure/">DataStructure</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/2021/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据结构：图</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/2021/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">
                        <span class="hidden-mobile">数据结构：查找算法</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.min.js', function () {
        var gitalk = new Gitalk({
          clientID: 'af550312a411b96c64b9',
          clientSecret: 'f11934265fd18324cb2d9fd605d7d445207a3e52',
          repo: 'gitalk',
          owner: 'AtroxQW',
          admin: ["AtroxQW"],
          id: '53cd38c1127c7eb50ef3ceec38e81f68',
          language: 'zh-CN',
          labels: ["Gitalk"],
          perPage: 10,
          pagerDirection: 'last',
          createIssueManually: true,
          distractionFreeMode: false
        });
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<!-- hexo injector body_end start --><script src = 'https://libs.xiaoz.top/instantclick/instantclick.min.js' data-no-instant></script>
<script data-no-instant>InstantClick.init();</script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
