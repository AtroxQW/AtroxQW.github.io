<!DOCTYPE html><html lang="en" data-default-color-scheme="&quot;auto&quot;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/img/blog/fav.jpg"><link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/img/blog/fav.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="codeAtrox"><meta name="keywords" content=""><title>单链表及其基本操作的实现 - Atrox的博客</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,onlypost:!1},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>AtroxQW</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于我</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/bg/atrox1.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="单链表及其基本操作的实现"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-04-05 15:26" pubdate>April 5, 2021 pm</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 13.8k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 188 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">单链表及其基本操作的实现</h1><div class="markdown-body"><h3 id="单链表"><a class="header-anchor" href="#单链表">¶</a>单链表</h3><h4 id="1-单链表的定义"><a class="header-anchor" href="#1-单链表的定义">¶</a>1.单链表的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表的结点类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>	<span class="hljs-keyword">int</span> data; <span class="hljs-comment">//数据域 </span><br>	LNode *next; <span class="hljs-comment">// 指针域 </span><br>&#125;LNode, *LinkList;<br></code></pre></td></tr></table></figure><p>等价于下面的定义方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;；<br><span class="hljs-comment">// 将 struct LNode 这个类型命名为 LNode，以后直接使用 LNode 0即可</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> <span class="hljs-title">LNode</span>;</span><br><span class="hljs-comment">// 定义 LinkList 指针指向 LNode 这个结构，通常用作单链表的头指针（和头结点进行区分）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">LinkList</span>;</span><br></code></pre></td></tr></table></figure><h4 id="2-初始化空的单链表和单链表判空"><a class="header-anchor" href="#2-初始化空的单链表和单链表判空">¶</a>2.初始化空的单链表和单链表判空</h4><p><strong>初始化单链表</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化一个空的单链表(带头结点)</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InitLinkList</span><span class="hljs-params">(LinkList &amp;L)</span> </span>&#123;<br>	L = (LNode *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(LNode));<br>	<span class="hljs-keyword">if</span>(L == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	L-&gt;next = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>单链表判空</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表判空</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LinkList L)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> L-&gt;next ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="3-单链表按位序插入元素"><a class="header-anchor" href="#3-单链表按位序插入元素">¶</a>3.单链表按位序插入元素</h4><p>将值为 e 的新结点插入到单链表的第 i 个位置上。我们需要先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第 i - 1 个结点，然后再其后插入新结点。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-comment">// 单链表长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Length</span><span class="hljs-params">(LinkList L)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(IsEmpty(L)) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>	LNode *p = L;<br>	<span class="hljs-keyword">while</span>(p-&gt;next) &#123;<br>		p = p-&gt;next;<br>		length++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> length;<br>&#125; <br> <br><span class="hljs-comment">// 单链表按位序插入元素</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> e)</span> </span>&#123;<br>	<span class="hljs-comment">// 判断插入位序的合法性 </span><br>	<span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; Length(L) + <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	LNode *p = L;<br>	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;  <br>	<span class="hljs-comment">// 找到待插入位置的前驱结点</span><br>	<span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i - <span class="hljs-number">1</span>) &#123;<br>		p = p-&gt;next;<br>		j++;<br>	&#125; <br>	<span class="hljs-comment">// 创造新结点</span><br>	LNode *s = (LNode *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(LNode));<br>	s-&gt;data = e;<br>	s-&gt;next = p-&gt; next;<br>	p-&gt;next = s;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="4-单链表在某个结点之后插入元素"><a class="header-anchor" href="#4-单链表在某个结点之后插入元素">¶</a>4.单链表在某个结点之后插入元素</h4><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表在指定结点后插入元素</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InsertNextNode</span><span class="hljs-params">(LNode *p, <span class="hljs-keyword">int</span> e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!p) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    LNode *temp = (LNode *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(LNode));<br>    temp-&gt;data = e;<br>    temp-&gt;next = p-&gt;next-&gt;next;<br>    p-&gt;next = temp;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-单链表在某个结点之前插入元素"><a class="header-anchor" href="#5-单链表在某个结点之前插入元素">¶</a>5. 单链表在某个结点之前插入元素</h4><p><strong>要求</strong>：将值为 e 的元素插入到 p 结点之前。</p><p><strong>思路</strong>：如果能传入头结点，那么可以从头开始遍历，如果当前结点的后继结点是 p 结点，那么就在当前结点和 p 结点之间插入值为 e 的元素。这样做的时间复杂度为 O(n);</p><p>现在有一种更简单的办法，即新建一个结点 s 将 p 结点的数据信息拷贝到 s 结点中，然后将原来的 p 结点的值替换为 e，就变相实现了在 p 结点之前插入值为 e 的结点。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表：在 p 结点之前插入元素 e</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InsertPriorNode</span><span class="hljs-params">(LNode *p, <span class="hljs-keyword">int</span> e)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(!p) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	LNode *s = (LNode *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(LNode));<br>	<span class="hljs-keyword">if</span>(!s) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	s-&gt;next = p-&gt;next;<br>	p-&gt;next = s;<br>	s-&gt;data = p-&gt;data;<br>	p-&gt;data = e;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="6-单链表的删除操作"><a class="header-anchor" href="#6-单链表的删除操作">¶</a>6.单链表的删除操作</h4><p>删除结点的操作是将单链表的第 i 个元素删除。先检查删除位置的合法性，后查找表中第 i - 1 个结点，即被删除结点的前驱节点，在将其删除。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表删除操作</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> &amp;deleteValue)</span> </span>&#123;<br>    <span class="hljs-comment">// 检查删除位序的合理性 </span><br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; Length(L)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 当前结点 </span><br>    LNode *curNode = L;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// curNode 指向待删除结点的前驱结点 </span><br>    <span class="hljs-keyword">while</span>(curNode &amp;&amp; j &lt; i - <span class="hljs-number">1</span>) &#123;<br>        curNode = curNode-&gt;next;<br>        j++;<br>    &#125; <br>    LNode *deleteNode = curNode-&gt;next;<br>    deleteValue = deleteNode-&gt;data; <br>    curNode-&gt;next = curNode-&gt;next-&gt;next;<br>    <span class="hljs-built_in">free</span>(deleteNode);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>单链表删除操作的平均时间复杂度为O(n)。</p><h4 id="7-单链表删除指定的结点"><a class="header-anchor" href="#7-单链表删除指定的结点">¶</a>7.单链表删除指定的结点</h4><p>要删除某个给定的结点 p，通常有两种做法，一种是从链表的头结点开始找到 p 的前驱结点，然后进行删除操作。还有一种方法，类似与上面 4 中的“偷天换日”。</p><p>具体做法为：创造指针 temp 指向 待删除结点 p 的后继，然后将 temp 的值和后继拷贝给 p，再释放 temp结点。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表删除特定的结点</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeleteNode</span><span class="hljs-params">(LNode *p)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(!p) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	LNode *temp = p-&gt;next;<br>	p-&gt;data = temp-&gt;data;<br>	p-&gt;next = temp-&gt;next;<br>	<span class="hljs-built_in">free</span>(temp);<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="8-按序号查找结点"><a class="header-anchor" href="#8-按序号查找结点">¶</a>8.按序号查找结点</h4><p>从单链表中第一个元素触发，顺着向下寻找到第 i 个结点即可。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 按序号查找结点</span><br><span class="hljs-function">LNode *<span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt; Length(L)) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-keyword">return</span> L;<br>	&#125;<br>	LNode *curNode = L-&gt;next;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>		curNode = curNode-&gt;next;	<br>	&#125;<br>	<span class="hljs-keyword">return</span> curNode;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="9-按值查找结点"><a class="header-anchor" href="#9-按值查找结点">¶</a>9.按值查找结点</h4><p>从单链表的第一个结点开始，从前往后依次比较表中各结点数据域的值，若某结点数据与的值等于指定值 e ，返回该节点即可。若表中没有这样的结点，返回 NULL。</p><p><strong>代码</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 按值查找结点</span><br><span class="hljs-function">LNode *<span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L, <span class="hljs-keyword">int</span> e)</span> </span>&#123;<br>	LNode *curNode = L-&gt;next;<br>	<span class="hljs-keyword">while</span>(curNode || curNode-&gt;data != e) &#123;<br>		curNode = curNode-&gt;next;<br>	&#125; <br>	<span class="hljs-keyword">return</span> curNode;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="10-尾插法建立单链表"><a class="header-anchor" href="#10-尾插法建立单链表">¶</a>10.尾插法建立单链表</h4><p>设置一个指针，将指针指向单链表的尾部结点，当需要插入结点时，只需要实现一个后插操作即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 尾插法建立单链表</span><br><span class="hljs-function">LinkList <span class="hljs-title">List_TailInsert</span><span class="hljs-params">(LinkList &amp;L)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> value;<br>	L = (LinkList) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(LNode));<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>	LNode *newNode = <span class="hljs-literal">NULL</span>;<br>	LNode *tailNode = L;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value);<br>	<span class="hljs-comment">// 用户输入99999表示结束  </span><br>	<span class="hljs-keyword">while</span>(value != <span class="hljs-number">99999</span>) &#123;<br>		newNode = (LNode *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(LNode));<br>		newNode-&gt;data = value;<br>		tailNode-&gt;next = newNode;<br>		tailNode = newNode;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value);<br>	&#125;<br>	<span class="hljs-comment">// 尾结点后继指针置空 </span><br>	tailNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> L; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-头插法建立单链表"><a class="header-anchor" href="#11-头插法建立单链表">¶</a>11.头插法建立单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 头插法建立单链表</span><br><span class="hljs-function">LinkList <span class="hljs-title">List_HeadInsert</span><span class="hljs-params">(LinkList &amp;L)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> value;<br>	L = (LinkList) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(LNode));<br>	L-&gt;next = <span class="hljs-literal">NULL</span>;<br>	LNode *newNode = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value);<br>	<span class="hljs-comment">// 用户输入99999表示结束  </span><br>	<span class="hljs-keyword">while</span>(value != <span class="hljs-number">99999</span>) &#123;<br>		newNode = (LNode *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(LNode));<br>		newNode-&gt;data = value;<br>		newNode-&gt;next = L-&gt;next;<br>		L-&gt;next = newNode;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value);<br>	&#125;<br>	<span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-遍历单链表内容"><a class="header-anchor" href="#12-遍历单链表内容">¶</a>12.遍历单链表内容</h4><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 输出单链表内容</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(LinkList L)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(IsEmpty(L)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！&quot;</span>);<br>        <span class="hljs-keyword">return</span>; <br>    &#125;<br>    LNode *curNode = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(curNode-&gt;next) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, curNode-&gt;data);<br>        curNode = curNode-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, curNode-&gt;data);<br><br>&#125; <br></code></pre></td></tr></table></figure><h4 id="13-总体代码"><a class="header-anchor" href="#13-总体代码">¶</a>13.总体代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 定义数据元素类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> elemType;<br><br><span class="hljs-comment">// 单链表结点存储结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span><br>	elemType data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>* <span class="hljs-title">next</span>;</span><br>&#125;LNode, * singleLinkList;<br><br><span class="hljs-comment">// 初始化单链表（无头结点）</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">initSingleLinkListWinthoutHead</span><span class="hljs-params">(singleLinkList&amp; L)</span> </span>&#123;<br><br>	L = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">// 初始化单链表（带头结点）</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">initSingleLinkListWithHead</span><span class="hljs-params">(singleLinkList&amp; L)</span> </span>&#123;<br><br>	L = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br><br>	<span class="hljs-comment">// 查看是否给头结点分配了存储空间</span><br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 对头指针 L 指向的头结点进行初始化</span><br>	L-&gt;next = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">// 单链表判空（无头结点）</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty2</span><span class="hljs-params">(singleLinkList L)</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>&#125;<br><br><span class="hljs-comment">// 单链表判空（有头结点）</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(singleLinkList L)</span></span>&#123;<br>	<br>	<span class="hljs-keyword">return</span> L-&gt;next ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">// 头插法建立单链表,输入54321，得到链表1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="hljs-function">singleLinkList <span class="hljs-title">headInsertList</span><span class="hljs-params">(singleLinkList &amp;L)</span> </span>&#123;<br>	<br>	<span class="hljs-comment">// 用户需要循环输入的元素值</span><br>	elemType value; <br>	LNode* newNode = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value);<br><br>	<span class="hljs-comment">// 设置 886 为退出标志</span><br>	<span class="hljs-keyword">while</span> (value != <span class="hljs-number">886</span>) &#123;<br><br>		<span class="hljs-comment">// 给新结点分配空间和设置属性</span><br>		newNode = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>		newNode-&gt;data = value;<br>		newNode-&gt;next = L-&gt;next;<br><br>		<span class="hljs-comment">// 将新结点插入到头结点的后面</span><br>		L-&gt;next = newNode;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value);<br>	<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> L;<br><br>&#125;<br><br><span class="hljs-comment">// 尾插法建立单链表,输入12345，得到1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="hljs-function">singleLinkList <span class="hljs-title">tailInsertList</span><span class="hljs-params">(singleLinkList &amp;L)</span> </span>&#123;<br>	<br>	<span class="hljs-comment">// 用户需要循环输入的元素值</span><br>	elemType value;<br>	<span class="hljs-comment">// 尾指针</span><br>	LNode* tailNode = L;<br>	LNode* newNode = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value);<br><br>	<span class="hljs-comment">// 设置 886 为退出标志</span><br>	<span class="hljs-keyword">while</span> (value != <span class="hljs-number">886</span>) &#123;<br><br>		<span class="hljs-comment">// 给新结点分配空间和设置属性</span><br>		newNode = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>		newNode-&gt;data = value;<br>		newNode-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>		<span class="hljs-comment">// 将新结点插入到尾结点的后面</span><br>		tailNode-&gt;next = newNode;<br>		tailNode = newNode;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value);<br><br>	&#125;<br><br>	<span class="hljs-comment">// 将尾结点后继指针设为空</span><br>	tailNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> L;<br><br>&#125;<br><br><span class="hljs-comment">// 顺序打印单链表内容</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(singleLinkList L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (isEmpty(L) == <span class="hljs-literal">true</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表内容为空！\n&quot;</span>);<br>	&#125;<br>	<span class="hljs-comment">// 设置当前结点指针遍历链表</span><br>	LNode *currentNode = L-&gt;next;<br>	<span class="hljs-keyword">while</span> (currentNode-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, currentNode-&gt;data);<br>		currentNode = currentNode-&gt;next;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, currentNode-&gt;data);<br><br>&#125;<br><br><span class="hljs-comment">// 获取当前单链表长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(singleLinkList L)</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> || isEmpty(L) == <span class="hljs-literal">true</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br>	<span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>	LNode* currentNode = L-&gt;next;<br>	<br>	<span class="hljs-keyword">while</span> (currentNode != <span class="hljs-literal">NULL</span>) &#123;<br>		length++;<br>		currentNode = currentNode-&gt;next;<br>	&#125;<br>	<span class="hljs-keyword">return</span> length;<br><br>&#125;<br><br><span class="hljs-comment">// 按位序 i 查找结点</span><br><span class="hljs-function">LNode* <span class="hljs-title">getElem</span><span class="hljs-params">(singleLinkList L, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>	<br>	<span class="hljs-comment">// 验证查找次序的合法性</span><br>	<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; getLength(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入位序不合法！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 计数器</span><br>	<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// 当前结点</span><br>	LNode* currentNode = L;<br><br>	<span class="hljs-keyword">while</span> (cnt &lt; i) &#123;<br>		currentNode = currentNode-&gt;next;<br>		cnt++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> currentNode;<br><br>&#125;<br><br><span class="hljs-comment">// 按值查找结点，查找失败返回 NULL</span><br><span class="hljs-function">LNode* <span class="hljs-title">locateElem</span><span class="hljs-params">(singleLinkList L, elemType value)</span> </span>&#123;<br><br>	<span class="hljs-comment">// 判断单链表是否为空</span><br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> || isEmpty(L) == <span class="hljs-literal">true</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	LNode* currentNode = L-&gt;next;<br>	<span class="hljs-keyword">while</span> (currentNode != <span class="hljs-literal">NULL</span> &amp;&amp; currentNode-&gt;data != value) &#123;<br>		currentNode = currentNode-&gt;next;<br>	&#125;<br>	<span class="hljs-keyword">return</span> currentNode;<br><br>&#125;<br><br><span class="hljs-comment">// 插入结点：将结点值为 value 的结点插入到第 i 个位置上</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(singleLinkList&amp; L, elemType value, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>	<br>	<span class="hljs-comment">// 检查插入位置的合法性</span><br>	<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; getLength(L) + <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置不合法！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-comment">// 找到第 i 个位置上元素的前驱结点</span><br>	LNode* beforeNode = getElem(L, i - <span class="hljs-number">1</span>);<br>	<br>	<span class="hljs-comment">// 创建新结点</span><br>	LNode* newNode = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>	<span class="hljs-keyword">if</span> (newNode == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;新结点插入失败！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		newNode-&gt;data = value;<br>		newNode-&gt;next = beforeNode-&gt;next;<br>		beforeNode-&gt;next = newNode;<br>	&#125;<br><br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">// 删除结点：将第 i 个位置上的结点删除</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(singleLinkList&amp; L, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-comment">// 检查删除位置的合法性</span><br>	<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; getLength(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除位置不合法！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 找到第 i 个位置上的前驱结点</span><br>	LNode* beforeNode = getElem(L, i - <span class="hljs-number">1</span>);<br>	<span class="hljs-comment">// 待删除结点</span><br>	LNode* deleteNode = beforeNode-&gt;next;<br><br>	<span class="hljs-comment">// 删除该结点</span><br>	beforeNode-&gt;next = beforeNode-&gt;next-&gt;next;<br>	<span class="hljs-built_in">free</span>(deleteNode);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">// 单链表在某结点 p 之后插入元素值为 value 的元素</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insertNextNode</span><span class="hljs-params">(LNode* p, elemType value)</span> </span>&#123;<br>	<br>	<span class="hljs-comment">// 判断传入结点的合法性</span><br>	<span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;传入结点不合法！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 建立值为 value 的新结点</span><br>	LNode* q = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>	<span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入结点失败！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	q-&gt;data = value;<br>	q-&gt;next = p-&gt;next;<br>	p-&gt;next = q;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">// 单链表在某结点 p 之前插入元素值为 value 的元素</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insertPriorNode</span><span class="hljs-params">(LNode* p, elemType value)</span> </span>&#123;<br>	<br>	<span class="hljs-comment">// 判断传入结点的合法性</span><br>	<span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;传入结点不合法！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 备份结点 p 信息为结点 tempNode 放在 p 后面</span><br>	LNode* tempNode = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>	<span class="hljs-keyword">if</span> (tempNode = <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入结点失败！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	tempNode-&gt;data = p-&gt;data;<br>	tempNode-&gt;next = p-&gt;next;<br>	<br>	<span class="hljs-comment">// 将值为 value 的新结点放在 p 结点前面（本质是将原来 p 结点的信息改为新结点信息）</span><br>	p-&gt;data = value;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>	<span class="hljs-comment">// 定义单链表</span><br>	singleLinkList L;<br><br>	<span class="hljs-comment">// 测试初始化单链表</span><br>	<span class="hljs-comment">// bool flag = initSingleLinkListWinthoutHead(L);</span><br>	<span class="hljs-keyword">bool</span> flag = initSingleLinkListWithHead(L);<br>	<span class="hljs-comment">// printf(&quot;flag = %d\n&quot;, flag);</span><br><br>	<span class="hljs-comment">// 测试单链表判空</span><br>	<span class="hljs-comment">//bool empty = isEmpty2(L);</span><br>	<span class="hljs-comment">//bool empty = isEmpty(L);</span><br>	<span class="hljs-comment">//printf(&quot;flag = %d\n&quot;, empty);</span><br>	<br><br>	<span class="hljs-comment">// 测试头插法和尾插法建立单链表</span><br>	<span class="hljs-comment">//headInsertList(L);</span><br>	tailInsertList(L);<br><br>	<span class="hljs-comment">// 测试顺序打印单链表</span><br>	<span class="hljs-comment">//printList(L);</span><br><br>	<span class="hljs-comment">// 测试获取单链表长度</span><br>	<span class="hljs-comment">//int length = getLength(L);</span><br>	<span class="hljs-comment">//printf(&quot;length = %d\n&quot;, length);</span><br><br>	<span class="hljs-comment">// 测试按序号查找结点</span><br>	<span class="hljs-comment">/*int i = 3;</span><br><span class="hljs-comment">	printf(&quot;单链表第%d个结点值为%d\n&quot;, i, getElem(L, i)-&gt;data);*/</span><br><br>	<span class="hljs-comment">// 测试按值查找结点</span><br>	<span class="hljs-comment">/*elemType value = 3;</span><br><span class="hljs-comment">	printf(&quot;结点值为%d\n&quot;, locateElem(L, value)-&gt;data);*/</span> <br><br>	<span class="hljs-comment">// 测试插入结点</span><br>	<span class="hljs-comment">/*insertNode(L, 555, 4);*/</span><br><br>	<span class="hljs-comment">// 测试删除结点</span><br>	<span class="hljs-comment">//deleteNode(L, 5);</span><br><br>	printList(L);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​</p><h3 id="双链表"><a class="header-anchor" href="#双链表">¶</a>双链表</h3><p>单链表只有一个后继指针区域，逆向检索太过麻烦；双向链表有前驱和后继两个指针域，克服了单链表的这一缺点。</p><h4 id="1-双向链表的定义"><a class="header-anchor" href="#1-双向链表的定义">¶</a>1.双向链表的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 双向链表结点类型 </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span> &#123;</span><br>	ElemType data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span> *<span class="hljs-title">prior</span>, *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">// 前驱和后继指针 </span><br>&#125;DNode, *DLinkList;<br></code></pre></td></tr></table></figure><h4 id="2-双向链表的初始化"><a class="header-anchor" href="#2-双向链表的初始化">¶</a>2.双向链表的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InitDLinkList</span><span class="hljs-params">(DLinkList &amp;L)</span> </span>&#123;<br>    L = (DNode *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(DNode));<br>    <span class="hljs-keyword">if</span>(!L) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    L-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    L-&gt;next = NUL;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-插入新结点"><a class="header-anchor" href="#3-插入新结点">¶</a>3.插入新结点</h4><p>在 p 结点之后插入新结点 s。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InsertNextNode</span><span class="hljs-params">(DNode *p, DNode *s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!p || !s) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    s-&gt;next = p-&gt;next;<br>    <span class="hljs-keyword">if</span>(p-&gt;next) &#123;<br>       p-&gt;next-&gt;prior; <br>    &#125;<br>    s-&gt;prior = p;<br>    p-&gt;next = s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-删除结点"><a class="header-anchor" href="#4-删除结点">¶</a>4.删除结点</h4><p>删除 p 结点的后继结点</p><p><strong>代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeleteNextNode</span><span class="hljs-params">(DNode *p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!p) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    DNode *deleteNode = p-&gt;next;<br>    <span class="hljs-keyword">if</span>(!deleteNode) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    p-&gt;next = deleteNode-&gt;next;<br>    <span class="hljs-keyword">if</span>(deleteNode-&gt;next) &#123;<br>        deleteNode-&gt;next-&gt;prior = p;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(deleteNode);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-双链表的遍历"><a class="header-anchor" href="#5-双链表的遍历">¶</a>5.双链表的遍历</h4><p><strong>代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PrintDLinkList</span><span class="hljs-params">(DLinkList L)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(!L) &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <br>    &#125;   <br>    DNode *curNode = L-&gt;next;<br>    <span class="hljs-keyword">if</span>(curNode) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, curNode-&gt;data);<br>    	curNode = curNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-总体代码"><a class="header-anchor" href="#6-总体代码">¶</a>6.总体代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 定义数据元素类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> elemType;<br><br><span class="hljs-comment">// 双向链表结点存储结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLNode</span> &#123;</span><br>	elemType data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLNode</span>* <span class="hljs-title">prior</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLNode</span>* <span class="hljs-title">next</span>;</span><br>&#125;DLNode, * doubleLinkList;<br><br><span class="hljs-comment">// 初始化双向链表（带头结点）</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">initDoubleLinkList</span><span class="hljs-params">(doubleLinkList &amp;L)</span> </span>&#123;<br><br>	L = (DLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLNode));<br><br>	<span class="hljs-comment">// 查看是否给头结点分配了存储空间</span><br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化双向链表失败！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 对头指针 L 指向的头结点进行初始化</span><br>	L-&gt;prior = <span class="hljs-literal">NULL</span>;<br>	L-&gt;next = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">// 双向链表判空（有头结点）</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(doubleLinkList L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">return</span> L-&gt;next ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">// 双向链表尾插法</span><br><span class="hljs-function">doubleLinkList <span class="hljs-title">tailInsertList</span><span class="hljs-params">(doubleLinkList &amp;L)</span> </span>&#123;<br><br>	<span class="hljs-comment">// 判断双向链表是否已初始化</span><br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;双向链表尚未初始化！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> L;<br>	&#125;<br><br>	<span class="hljs-comment">// 待尾插的结点元素值 </span><br>	elemType value;<br>	DLNode* newNode = <span class="hljs-literal">NULL</span>;<br>	DLNode* tailNode = L;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value);<br>	<br>	<span class="hljs-comment">// 输入元素值为 886 为结束标志</span><br>	<span class="hljs-keyword">while</span> (value != <span class="hljs-number">886</span>) &#123;<br><br>		newNode = (DLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLNode));<br>		newNode-&gt;data = value;<br>		newNode-&gt;prior = tailNode;<br>		tailNode-&gt;next = newNode;<br>		tailNode = newNode;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value);<br>	&#125;<br>	tailNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> L;<br><br>&#125;<br><br><span class="hljs-comment">// 顺序打印双向链表内容</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(doubleLinkList L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (isEmpty(L) == <span class="hljs-literal">true</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;双向链表内容为空！\n&quot;</span>);<br>	&#125;<br>	<span class="hljs-comment">// 设置当前结点指针遍历链表</span><br>	DLNode* currentNode = L-&gt;next;<br>	<span class="hljs-keyword">while</span> (currentNode-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, currentNode-&gt;data);<br>		currentNode = currentNode-&gt;next;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, currentNode-&gt;data);<br><br>&#125;<br><br><span class="hljs-comment">// 获取当前双向链表长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(doubleLinkList L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> || isEmpty(L) == <span class="hljs-literal">true</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br>	<span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>	DLNode* currentNode = L-&gt;next;<br><br>	<span class="hljs-keyword">while</span> (currentNode != <span class="hljs-literal">NULL</span>) &#123;<br>		length++;<br>		currentNode = currentNode-&gt;next;<br>	&#125;<br>	<span class="hljs-keyword">return</span> length;<br><br>&#125;<br><br><span class="hljs-comment">// 按照位序 i 查找结点</span><br><span class="hljs-function">DLNode* <span class="hljs-title">getElem</span><span class="hljs-params">(doubleLinkList L, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>	<br>	<span class="hljs-comment">// 验证查找次序的合法性</span><br>	<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; getLength(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入位序不合法！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 计数器</span><br>	<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// 当前结点</span><br>	DLNode* currentNode = L;<br><br>	<span class="hljs-keyword">while</span> (cnt &lt; i) &#123;<br>		currentNode = currentNode-&gt;next;<br>		cnt++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> currentNode;<br><br>&#125;<br><br><br><span class="hljs-comment">// 插入操作：在双向链表第 i 个位置上插入值为 value 的结点</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(doubleLinkList &amp;L, <span class="hljs-keyword">int</span> i, elemType value)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;双向链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 找到第 i 个位置结点的前驱结点</span><br>	DLNode* beforeNode = getElem(L, i - <span class="hljs-number">1</span>);<br><br>	<span class="hljs-comment">// 新建结点</span><br>	DLNode* newNode = (DLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLNode));<br>	<span class="hljs-keyword">if</span> (newNode == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;结点插入失败！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	newNode-&gt;data = value;<br>	newNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>	newNode-&gt;prior = <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-comment">// 插入新结点</span><br>	newNode-&gt;next = beforeNode-&gt;next;<br>	newNode-&gt;prior = beforeNode;<br>	<span class="hljs-keyword">if</span> (beforeNode-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>		beforeNode-&gt;next-&gt;prior = newNode;<br>	&#125;<br>	beforeNode-&gt;next = newNode;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">// 删除操作：删除双向链表第 i 个位置上的结点</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(doubleLinkList&amp; L, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!L || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;双向链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 判断删除位置的合法性</span><br>	<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; getLength(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除位置有误！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 找到待删除结点的前驱结点</span><br>	DLNode* beforeNode = getElem(L, i - <span class="hljs-number">1</span>);<br>	DLNode* deleteNode = beforeNode-&gt;next;<br>	<br>	<span class="hljs-comment">// 删除结点</span><br>	<span class="hljs-keyword">if</span> (deleteNode-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>		deleteNode-&gt;next-&gt;prior = beforeNode;<br>	&#125;<br>	beforeNode-&gt;next = deleteNode-&gt;next;<br>	<span class="hljs-built_in">free</span>(deleteNode);<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>	<span class="hljs-comment">// 定义双向链表</span><br>	doubleLinkList L;<br><br>	<span class="hljs-comment">// 测试初始化双向链表</span><br>	<span class="hljs-keyword">bool</span> flag = initDoubleLinkList(L);<br>	<span class="hljs-comment">/*printf(&quot;flag = %d\n&quot;, flag);*/</span><br><br>	<span class="hljs-comment">// 测试尾插法</span><br>	tailInsertList(L);<br><br>	<span class="hljs-comment">// 测试插入结点</span><br>	<span class="hljs-comment">//insertNode(L, 5, 666);</span><br><br>	<span class="hljs-comment">// 测试删除结点</span><br>	<span class="hljs-comment">//deleteNode(L, 4);</span><br><br>	printList(L);<br>	<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环链表"><a class="header-anchor" href="#循环链表">¶</a>循环链表</h3><h4 id="1-循环单链表"><a class="header-anchor" href="#1-循环单链表">¶</a>1. 循环单链表</h4><p>循环单链表和普通单链表的区别在于，表中最后一个结点的 next 指针不是指向 NULL，而是指向<strong>头结点</strong>（注意是头结点而不是第一个结点）。</p><h4 id="2-循环双链表"><a class="header-anchor" href="#2-循环双链表">¶</a>2.循环双链表</h4><p>由循环单链表的定义不难推出循环双链表的定义，只需要，将头结点的 prior 指针指向表尾结点即可。</p><h4 id="3-初始化循环链表"><a class="header-anchor" href="#3-初始化循环链表">¶</a>3.初始化循环链表</h4><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span> </span>&#123;<br>    L = (LNode *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(LNode));<br>    <span class="hljs-keyword">if</span>(!L) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 循环单链表</span><br>    L-&gt;next = L;<br>    <span class="hljs-comment">// 循环双链表</span><br>    L-&gt;prior = L;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态链表"><a class="header-anchor" href="#静态链表">¶</a>静态链表</h3><p>静态链表借助数组来描述线性表的链式存储结构，结点也有数据域 data 和 “指针域” next ，与前面所讲的链表的指针不同的是，<strong>这里的指针是结点的相对地址（数组下标）</strong>，又称游标。和顺序表一样，静态链表也需要预先分配一块连续的内存空间。</p><h4 id="1-静态链表的定义"><a class="header-anchor" href="#1-静态链表的定义">¶</a>1.静态链表的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-comment">// 指向下一结点的下标</span><br>    <span class="hljs-keyword">int</span> next;<br>&#125; SLinkList[MaxSize];<br><br><span class="hljs-comment">// 以后定义 A 即为大小为 MaxSize 的数组 </span><br>SLinkList A;<br></code></pre></td></tr></table></figure><p>静态链表以 <code>next == -1</code>作为结束的标志。</p><h4 id="2-插入删除操作"><a class="header-anchor" href="#2-插入删除操作">¶</a>2.插入删除操作</h4><p><strong>插入位序为 i 的结点</strong>：</p><ol><li>找到一个空的结点，存入数据元素</li><li>从头结点出发找到位序为 i - 1 的结点</li><li>修改新结点的 next</li><li>修改第 i - 1 号结点的 next</li></ol><p><strong>删除某个结点</strong>：</p><ol><li>从头结点出发找到前驱结点</li><li>修改前驱结点的游标</li><li>被删除结点 next 设为 -2</li></ol><h3 id="顺序表-V-S-链表"><a class="header-anchor" href="#顺序表-V-S-链表">¶</a>顺序表 V.S. 链表</h3><h4 id="1-逻辑结构和物理结构"><a class="header-anchor" href="#1-逻辑结构和物理结构">¶</a>1.逻辑结构和物理结构</h4><p>顺序表逻辑上相邻的元素，再对应的物理存储位置也相邻；链表逻辑上相邻的元素，再物理位置上不一定相邻，对应的逻辑关系是通过指针来实现的。</p><h4 id="2-存储结构"><a class="header-anchor" href="#2-存储结构">¶</a>2.存储结构</h4><p>顺序表的存储结构为顺序存储，优点是能实现随机存取，缺点是需要提前预先分配存储空间，改变容量不方便。</p><p>链表的存储结构为链式存储，优点是离散的小空间分配，改变容量方便，缺点是不可随即存取，存储密度低。</p><h4 id="3-查找、插入、删除"><a class="header-anchor" href="#3-查找、插入、删除">¶</a>3.查找、插入、删除</h4><p><strong>查找</strong>：</p><ol><li>按值查找，顺序表无序时，顺序表和链表的时间复杂度都为O(N)；顺序表有序时，课采用折半查找，时间复杂度为 O(logN)。</li><li>按序号查找，顺序表支持随即访问，时间复杂度为O(1)，而链表的时间复杂度为O(N)。</li></ol><p><strong>插入</strong>：</p><p>顺序表的插入操作需要平均移动半个表长的元素，时间复杂度为O(N)，链表的插入操作时间复杂度为O(1).</p><p><strong>删除</strong>：</p><p>链表的删除操作也需要平均移动半个表长的元素，时间复杂度为O(N)，链表的删除操作时间复杂度为O(1).</p><h3 id="练习题"><a class="header-anchor" href="#练习题">¶</a>练习题</h3><h4 id="1-第一题"><a class="header-anchor" href="#1-第一题">¶</a>1.第一题</h4><p><strong>题目</strong>：设计一个递归算法，删除不带头结点的单链表 L 中所有值为 x 的结点。</p><p><strong>思路</strong>：审视题目发现关键词 <strong>递归算法</strong>，每当看到递归算法，总要回想起递归的三个特性。</p><ul><li>递归特性一：必须有一个明确的终止条件</li><li>递归特性二：每次递归问题规模都会缩小</li><li>递归特性三：递归层次过多会导致栈溢出</li></ul><p>我们想到，每次都给该算法传递 L 的一部分，该部分一开始为整个单链表 <code>delXElem(singleLinkList L, elemType x)</code>，每次判断过当前第一个结点是否值为 x (<code>L-&gt;data == x</code>)后，进行操作(删除或者什么都不做)。下一步传入 L 中该结点后面的部分。终止条件是给该算法传入的 L == NULL。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归删除单链表中值为 x 的元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delXElem</span><span class="hljs-params">(singleLinkList&amp; L, elemType x)</span> </span>&#123;<br><br>	<span class="hljs-comment">// 递归终止条件</span><br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 待删除结点</span><br>	LNode* deleteNode;<br><br>	<span class="hljs-keyword">if</span> (L-&gt;data == x) &#123;<br>		deleteNode = L;<br>		L = L-&gt;next;<br>		<span class="hljs-built_in">free</span>(deleteNode);<br>		delXElem(L, x);<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		delXElem(L-&gt;next, x);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-第二题"><a class="header-anchor" href="#2-第二题">¶</a>2.第二题</h4><p><strong>题目</strong>：在带头结点的单链表 L 中，删除所有值为 x 的结点，并释放其空间，假设值为 x 的结点不唯一，试编写算法已实现上述操作。</p><p><strong>思路</strong>：从头到尾扫描单链表 L，删除值为 x 的结点。设置 currentNode 为当前结点，priorNode 为 当前结点的前驱结点。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 删除单链表中所有值为 x 的元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteXElem</span><span class="hljs-params">(singleLinkList&amp; L, elemType x)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (L == NULL || isEmpty(L)) &#123;<br>		printf(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	LNode* currentNode = L-&gt;next;<br>	LNode* priorNode = L;<br>	LNode* deleteNode;<br><br>	<span class="hljs-keyword">while</span> (currentNode != NULL) &#123;<br>		<span class="hljs-keyword">if</span>(currentNode-&gt;data == x) &#123;<br>			<span class="hljs-comment">// 前驱结点不变，当前结点后移，删除值为 x 的结点</span><br>			priorNode-&gt;next = currentNode-&gt;next;<br>			deleteNode = currentNode;<br>			currentNode = currentNode-&gt;next;<br>			free(deleteNode);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// 前驱结点和当前结点同时后移</span><br>			priorNode = priorNode-&gt;next;<br>			currentNode = currentNode-&gt;next;<br>		&#125;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-第三题"><a class="header-anchor" href="#3-第三题">¶</a>3.第三题</h4><p><strong>题目</strong>：设 L 为带头结点的单链表， 编写算法实现从尾到头反向输出每个结点的值。、</p><p><strong>思路</strong>：单链表先遍历到的元素后输出，可以自然联想到使用栈的结构，但是这里只需要使用递归就能实现。当访问一个结点时，先递归输出他后面的结点，再输出该节点自身。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 逆序输出单链表元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reversePrintList</span><span class="hljs-params">(singleLinkList L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空!\n&quot;</span>);<br>	&#125;<br><br>	LNode* currentNode = L-&gt;next;<br>	<br>	<span class="hljs-comment">// 递归终止条件</span><br>	<span class="hljs-keyword">if</span> (currentNode == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">// 递归</span><br>		reversePrintList(L-&gt;next);<br>		<span class="hljs-comment">// 输出元素值</span><br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, currentNode-&gt;data);<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-第四题"><a class="header-anchor" href="#4-第四题">¶</a>4.第四题</h4><p><strong>题目</strong>：试编写在带头结点的单链表 L 中删除一个最小值结点的高效算法（假设最小值结点时唯一的）。</p><p><strong>思路</strong>：用 minNode 指针标记最小值结点。 用 minPriorNode 指针标记最小值结点的前驱结点。从头到尾遍历单链表 L，用 priorNode 标记当前结点 currentNode 的前驱结点，如果当 currentNode 指针指向的当前结点值小于 minNode 指向结点值，那么 <code>minNode = currentNode; minPriorNode = priorNode;</code>，如果不小于，则继续向后遍历，<code>currentNode = currentNode-&gt;next; priorNode = priorNode-&gt;next;</code>，结束条件为当前结点为 NULL。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除单恋表中唯一的最小值结点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteMinNode</span><span class="hljs-params">(singleLinkList&amp; L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	LNode* currentNode = L-&gt;next;<br>	LNode* priorNode = L;<br>	LNode* minPriorNode = L;<br>	LNode* minNode = currentNode;<br><br>	<span class="hljs-comment">// 定位最小值结点和其前驱结点</span><br>	<span class="hljs-keyword">while</span> (currentNode != <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">if</span> (currentNode-&gt;data &lt; minNode-&gt;data) &#123;<br>			minNode = currentNode;<br>			minPriorNode = priorNode;<br>		&#125;<br>		currentNode = currentNode-&gt;next;<br>		priorNode = priorNode-&gt;next;<br>	&#125;<br><br>	<span class="hljs-comment">// 删除最小值结点</span><br>	minPriorNode-&gt;next = minPriorNode-&gt;next-&gt;next;<br>	<span class="hljs-built_in">free</span>(minNode);<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-第五题"><a class="header-anchor" href="#5-第五题">¶</a>5.第五题</h4><p><strong>题目</strong>：试编写算法将带头结点的单链表就地逆置，所谓“就地”就是指辅助空间复杂度为0</p><p><strong>思路1</strong>：将单链表 L 的头结点和后面断开，currentNode 指向头结点后面的第一个结点，遍历后面的结点将其使用头插法插入到 L 中。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表就地逆置</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(singleLinkList&amp; L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!L || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	LNode* currentNode = L-&gt;next; <br>	<span class="hljs-comment">// 断链</span><br>	L-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-comment">// 遍历旧链表元素并头插入新链表</span><br>	<span class="hljs-keyword">while</span> (currentNode != <span class="hljs-literal">NULL</span>) &#123;<br>		<br>		LNode* insertNode = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>		insertNode-&gt;data = currentNode-&gt;data;<br>		insertNode-&gt;next = L-&gt;next;<br>		L-&gt;next = insertNode;<br>		currentNode = currentNode-&gt;next;<br><br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路2</strong>:假设 preNode、 currentNode 和 afterNode 指向当前结点的前驱结点、当前结点、当前结点的后继结点。每次遍历将 preNode 和 currentNode 之间的指针进行反转。因为将 currentNode 的后继指针指向 preNode 后，currentNode 之前的链就会断开。所以，在进行指针反转之前需要用 afterNode 保存 currentNode 的后继结点，来保证能够顺利的将 currentNode 进行向后遍历。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表逆置第二种方法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseList2</span><span class="hljs-params">(singleLinkList L)</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> || L-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-comment">// 初始化三个连续结点的指针</span><br>	LNode* preNode = L;<br>	LNode* currentNode = L-&gt;next;<br>	LNode* afterNode = currentNode-&gt;next;<br><br>	<span class="hljs-comment">// 将第一个结点作为最后一个结点</span><br>	currentNode-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-comment">// currentNode 从第二个结点开始到最后一个结点开始遍历</span><br>	<span class="hljs-keyword">while</span> (afterNode != <span class="hljs-literal">NULL</span>) &#123;<br>		preNode = currentNode;<br>		currentNode = afterNode;<br>		afterNode = afterNode-&gt;next;<br>		currentNode-&gt;next = preNode;<br>	&#125;<br><br>	<span class="hljs-comment">// 将头指针 L 指向第一个结点</span><br>	L-&gt;next = currentNode;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-第六题"><a class="header-anchor" href="#6-第六题">¶</a>6.第六题</h4><p><strong>题目</strong>:有一个带有头结点的单链表 L，设计一个算法使其元素递增有序。</p><p><strong>思路</strong>1：简单选择排序，从头到尾进行扫描，找到最小的放在第一个位置，再从第二个位置进行第二次扫描，找到最小的，放在第二个位置，直到全部有序。</p><p><strong>代码·</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 寻找单链表的最小结点(不带头结点)</span><br><span class="hljs-function">LNode* <span class="hljs-title">minNode</span><span class="hljs-params">(singleLinkList head)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	LNode* minNode = head;<br>	LNode* currentNode = minNode-&gt;next;<br>	<br>	<span class="hljs-keyword">while</span> (currentNode != <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">if</span> (currentNode-&gt;data &lt; minNode-&gt;data) &#123;<br>			minNode = currentNode;<br>		&#125;<br>		currentNode = currentNode-&gt;next;<br>	&#125;<br>	<span class="hljs-keyword">return</span> minNode;<br><br>&#125;<br><br><span class="hljs-comment">// 交换两个结点的值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swapNode</span><span class="hljs-params">(LNode* p, LNode* q)</span> </span>&#123;<br>	elemType temp;<br>	temp = p-&gt;data;<br>	p-&gt;data = q-&gt;data;<br>	q-&gt;data = temp;<br>&#125;<br><br><span class="hljs-comment">// 单链表选择排序(带头结点)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(singleLinkList &amp;L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// p 用来向后移动， q 用来保存最小结点</span><br>	LNode* p = L-&gt;next, * q = L-&gt;next;<br>	<span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-comment">// 寻找最小结点</span><br>		q = minNode(p);<br>		<span class="hljs-comment">// 与前面的结点进行交换</span><br>		swapNode(p, q);<br>		p = p-&gt;next;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路2</strong>:插入排序。将链表的第一个元素视为有序序列，将第二个元素到最后一个元素视为无序序列。将无序序列的第一个元素插入到有序序列的第一个正确的位置。</p><p><strong>代码</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将某结点插入到合适的位置以保持链表升序</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertNodeByAsc</span><span class="hljs-params">(singleLinkList&amp; L, LNode* p)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!L) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表尚未初始化！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (isEmpty(L)) &#123;<br>		L-&gt;next = p;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br><br>	LNode* currentNode = L-&gt;next;<br><br>	<span class="hljs-comment">// 如果只有一个元素并且大于待插入元素值</span><br>	<span class="hljs-keyword">if</span> (currentNode-&gt;next == <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;data &lt; currentNode-&gt;data) &#123;<br>		p-&gt;next = currentNode;<br>		L-&gt;next = p;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">while</span> (currentNode-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">if</span> (p-&gt;data &gt; currentNode-&gt;data) &#123;<br>			currentNode = currentNode-&gt;next;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// 在该结点前插入结点</span><br>			LNode* temp = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>			<span class="hljs-comment">// 将 currentNode 结点信息拷贝到 temp 结点中</span><br>			temp-&gt;next = currentNode-&gt;next;<br>			temp-&gt;data = currentNode-&gt;data;<br>			currentNode-&gt;next = temp;<br>			<span class="hljs-comment">// 将新结点信息覆盖到原来的 currentNode 结点上</span><br>			currentNode-&gt;data = p-&gt;data;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// 如果待插入元素值比单链表所有元素值都大</span><br>	currentNode-&gt;next = p;<br>&#125;<br><br><span class="hljs-comment">// 单链表插入排序(带头结点)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(singleLinkList L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 无序序列的指针</span><br>	LNode* currentNode = L-&gt;next-&gt;next;<br>	<br>	<span class="hljs-comment">// 无序序列和有序序列断开</span><br>	L-&gt;next-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-comment">// 遍历无序序列元素并一个个插入到合适的位置</span><br>	<span class="hljs-keyword">while</span> (currentNode != <span class="hljs-literal">NULL</span>) &#123;<br><br>		LNode* tempNode = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>		tempNode-&gt;data = currentNode-&gt;data;<br>		tempNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>		insertNodeByAsc(L, tempNode);<br>		currentNode = currentNode-&gt;next;<br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-第七题"><a class="header-anchor" href="#7-第七题">¶</a>7.第七题</h4><p><strong>题目</strong>：设在一个带头结点的单链表中所有元素结点的数据值无序，试编写一个函数，删除表中所有介于给定的两个值（作为函数参数给出）之间的元素。</p><p><strong>思路</strong>：依次遍历单链表元素，查看是否符合区间即可 。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除单链表居于给定的两个数之间的元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteNodeInRange</span><span class="hljs-params">(singleLinkList &amp;L, elemType m, elemType n)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!L || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	elemType left, right;<br>	<span class="hljs-keyword">if</span> (m &lt;= n) &#123;<br>		left = m;<br>		right = n;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		left = n;<br>		right = m;<br>	&#125;<br><br>	LNode* priorNode = L;<br>	LNode* currentNode = L-&gt;next;<br>	<br>	<span class="hljs-keyword">while</span> (currentNode != <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">if</span> (currentNode-&gt;data &gt;= left &amp;&amp; currentNode-&gt;data &lt;= right) &#123;<br>			priorNode-&gt;next = priorNode-&gt;next-&gt;next;<br>			currentNode = currentNode-&gt;next;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			priorNode = priorNode-&gt;next;<br>			currentNode = currentNode-&gt;next;<br>		&#125;<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="8-第八题"><a class="header-anchor" href="#8-第八题">¶</a>8.第八题</h4><p><strong>题目</strong>：给定两个单链表，编写算法找出两个链表的公共结点。</p><p><strong>思路</strong>：两个单链表有公共结点，也就是说<strong>两个链表从某一个结点开始，它们的 next 都指向同一个结点</strong>。由于每个单链表只有一个 next 域，因此从第一个公共结点开始，之后它们的所有结点都是重合的，不可能再出现分叉。所以，两个有公共结点而部分重合的单链表，拓扑形状看起来像 Y ， 而不可能像 X。</p><p><strong>参考文章</strong>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41740162/article/details/105349989">(14条消息) C语言 寻找两个单链表的公共节点实现与原理_<sub>搬</sub>运<sub>工</sub>的博客-CSDN博客</a></p><p><strong>图解</strong>：<img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/链表及其基本操作的实现/2.png" srcset="/img/loading.gif" alt="公共结点图解" style="zoom:67%"></p><p><strong>方法1</strong>:暴力法，使用两个循环。从第一个链表的头结点开始，再第二个链表找相同的结点。第一个没找到，开始走第一个链表的第二个结点，继续从第二个链表中从头开始找，直到找到为止。</p><p><strong>代码1·</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求取两个单链表的公共结点</span><br><span class="hljs-function">LNode* <span class="hljs-title">findCommonNode1</span><span class="hljs-params">(singleLinkList&amp; LA, singleLinkList&amp; LB)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!LA || !LB || !LA-&gt;next || !LB-&gt;next) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;两个单链表无公共结点！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	LNode* curNodeA = LA;<br>	LNode* curNodeB = LB;<br><br>	<span class="hljs-comment">// 双重循环嵌套暴力求解</span><br>	<span class="hljs-keyword">while</span> (curNodeA != <span class="hljs-literal">NULL</span>) &#123;<br><br>		curNodeB = LB;<br>		<span class="hljs-keyword">while</span> (curNodeB != <span class="hljs-literal">NULL</span>) &#123;<br>			<span class="hljs-keyword">if</span> (curNodeA == curNodeB) &#123;<br>				<span class="hljs-keyword">return</span> curNodeA;<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				curNodeB = curNodeB-&gt;next;<br>			&#125;<br>		&#125;<br><br>		curNodeA = curNodeA-&gt;next;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路2</strong>:先遍历两个链表求出它们的长度，当链表重合时，重合结点的后面的结点长度相同，只有前面的结点长度不同，求差。让较长的链表先走差值的长度，然后两个链表同时向后遍历，求公共结点。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求取两个单链表个公共结点2</span><br><span class="hljs-function">LNode* <span class="hljs-title">findCommonNode2</span><span class="hljs-params">(singleLinkList LA, singleLinkList LB)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!LA || !LB || !LA-&gt;next || !LB-&gt;next) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;两个单链表无公共结点！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">int</span> LALength = getLength(LA);<br>	<span class="hljs-keyword">int</span> LBLength = getLength(LB);<br>	<span class="hljs-comment">// 求两个单链表的长度差值</span><br>	<span class="hljs-keyword">int</span> lengthDiff;<br>	LNode* longListHead;<br>	LNode* shortListHead;<br><br>	<span class="hljs-comment">// 确定指针指向</span><br>	<span class="hljs-keyword">if</span> (LALength &gt; LBLength) &#123;<br>		lengthDiff = LALength - LBLength;<br>		longListHead = LA;<br>		shortListHead = LB;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		lengthDiff = LBLength - LALength;<br>		longListHead = LB;<br>		shortListHead = LA;<br>	&#125;<br><br>	<span class="hljs-comment">// 先对长链表进行移动，移动到与锻炼表长度相同的位置</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lengthDiff; i++) &#123;<br>		longListHead = longListHead-&gt;next;<br>	&#125;<br><br>	<span class="hljs-comment">// 寻找公共结点</span><br>	<span class="hljs-keyword">while</span> (longListHead != <span class="hljs-literal">NULL</span> &amp;&amp; shortListHead != <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">if</span> (longListHead == shortListHead) &#123;<br>			<span class="hljs-keyword">return</span> longListHead;<br>		&#125;<br>		longListHead = longListHead-&gt;next;<br>		shortListHead = shortListHead-&gt;next;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路3</strong>:</p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/链表及其基本操作的实现/2.png" srcset="/img/loading.gif" alt="公共结点图解" style="zoom:67%"><p>设置p指向4，q指向1。那么让p走过的顺序 4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;1-&gt;3-&gt;2-&gt;6，q走过的顺序为1-&gt;3-&gt;2-&gt;6-&gt;7-&gt;8-&gt;4-&gt;5。两个指针走过同样的路程会同时到达 6 这个公共结点。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求取两个单链表个公共结点3</span><br><span class="hljs-function">LNode* <span class="hljs-title">findCommonNode3</span><span class="hljs-params">(singleLinkList LA, singleLinkList LB)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!LA || !LB || !LA-&gt;next || !LB-&gt;next) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;两个单链表无公共结点！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	LNode* p = LA;<br>	LNode* q = LB;<br><br>	<span class="hljs-keyword">while</span> (p != q) &#123;<br>		<span class="hljs-keyword">if</span> (p)<br>			p = p-&gt;next;<br>		<span class="hljs-keyword">else</span><br>			p = LB;<br><br>		<span class="hljs-keyword">if</span> (q)<br>			q = q-&gt;next;<br>		<span class="hljs-keyword">else</span><br>			q = LA;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> p;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-第九题"><a class="header-anchor" href="#9-第九题">¶</a>9.第九题</h4><p><strong>题目</strong>：给定一个带头结点的单链表，设 head 为头指针，结点结构为 (data, next) ，data为整型元素， next 为指针，试写出算法：按递增次序输出单链表中各结点的数据元素并释放结点所占的存储空间（要求：不允许使用数组作为辅助空间）</p><p><strong>思路</strong>：题目对时间复杂度没有要求。可以暴力求解。对单链表每次遍历求出最小值结点，输出并删除它。直到单链表只剩下一个头结点为止。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 按递增顺序输出单链表数据元素（不使用数组）</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printListByAsc</span><span class="hljs-params">(singleLinkList L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!L || L-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空无元素！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">while</span> (L-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br><br>		<span class="hljs-comment">// 最小值结点的前驱结点</span><br>		LNode* priorNode = L;<br>		<span class="hljs-comment">// 工作结点指针</span><br>		LNode* currentNode = priorNode-&gt;next;<br>		LNode* minNode = currentNode;<br>		LNode* priorMinNode = priorNode;<br>		<span class="hljs-keyword">while</span> (currentNode != <span class="hljs-literal">NULL</span>) &#123;<br>			<span class="hljs-keyword">if</span> (currentNode-&gt;data &lt; minNode-&gt;data) &#123;<br>				minNode = currentNode;<br>				priorMinNode = priorNode;<br>			&#125;<br>			currentNode = currentNode-&gt;next;<br>			priorNode = priorNode-&gt;next;<br>		&#125;<br>		<span class="hljs-comment">// 输出最小值结点并将其删除</span><br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, minNode-&gt;data);<br>		priorMinNode-&gt;next = minNode-&gt;next;<br>		<span class="hljs-built_in">free</span>(minNode);<br>	<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-第十题"><a class="header-anchor" href="#10-第十题">¶</a>10.第十题</h4><p><strong>题目</strong>：将一个带头结点的单链表 L 分解为两个带头结点的单链表 A 和 B 。使得 A 表中含有原表中序号为奇数的元素。而 B 表中含有原表中序号为偶数的元素，且保持其相对顺序不变。</p><p><strong>思路</strong>：设置一个奇数结点指针指向 A，一个偶数结点指针指向 B。循环遍历单链表 L，奇数次序的插入到 奇数结点指针后面，同时奇数结点指针后移；偶数次序的插入到偶数结点指针后面，同时偶数结点指针后移。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将原链表分解为两个链表，分别为奇数序号元素和偶数序号元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resolveList</span><span class="hljs-params">(singleLinkList&amp; L, singleLinkList&amp; LA, singleLinkList&amp; LB)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!L || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原链表为空！\n&quot;</span>);<br>			<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (!LA || !LB) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要分解为的两个链表尚未初始化！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 奇数链表工作指针</span><br>	LNode* oddNode = LA;<br>	<span class="hljs-comment">// 偶数链表工作指针</span><br>	LNode* evenNode = LB;<br>	<span class="hljs-comment">// 原链表工作指针</span><br>	LNode* curNode = L-&gt;next;<br>	<span class="hljs-comment">// 记录原链表的结点序号</span><br>	<span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>	<br>	<span class="hljs-keyword">while</span> (curNode != <span class="hljs-literal">NULL</span>) &#123;<br><br>		num++;<br>		<span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>			oddNode-&gt;next = curNode;<br>			oddNode = oddNode-&gt;next;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			evenNode-&gt;next = curNode;<br>			evenNode = evenNode-&gt;next;<br>		&#125;<br>		curNode = curNode-&gt;next;<br><br>	&#125;<br>	<br>	oddNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>	evenNode-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>&#125;                      <br></code></pre></td></tr></table></figure><h4 id="11-第十一题"><a class="header-anchor" href="#11-第十一题">¶</a>11.第十一题</h4><p><strong>题目</strong>：设 C = ｛a1, b1, a2, b2, …, an, bn｝为线性表，采用带头结点的 hc 链表存放，设计一个就地算法，将其拆分为两个线性表，使得 A = ｛a1, a2, …, an｝， B = ｛bn, …, b2, b1｝.</p><p><strong>思路</strong>：对奇数元素的结点尾插法插入到一个链表，对偶数元素的结点头插到一个链表。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将单链表拆分为两个单链表，其中一个头插，一个尾插</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resolveList2</span><span class="hljs-params">(singleLinkList&amp; L, singleLinkList&amp; LA, singleLinkList&amp; LB)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!L || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (!LA || !LB) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要分解为的两个链表尚未初始化！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 奇数链表工作指针</span><br>	LNode* oddNode = LA;<br>	<span class="hljs-comment">// 原链表工作指针</span><br>	LNode* curNode = L-&gt;next;<br>	<span class="hljs-comment">// 记录原链表的结点序号</span><br>	<span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">while</span> (curNode != <span class="hljs-literal">NULL</span>) &#123;<br><br>		num++;<br>		<span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>			oddNode-&gt;next = curNode;<br>			oddNode = oddNode-&gt;next;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			LNode* tempNode = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>			tempNode-&gt;data = curNode-&gt;data;<br>			tempNode-&gt;next = LB-&gt;next;<br>			LB-&gt;next = tempNode;<br>		&#125;<br><br>		curNode = curNode-&gt;next;<br><br>	&#125;<br>	oddNode-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-第十二题"><a class="header-anchor" href="#12-第十二题">¶</a>12.第十二题</h4><p><strong>题目</strong>：在一个递增有序的线性表中，有数值相同的元素存在。若存储方式为单链表，设计算法去掉数值相同的元素。</p><p><strong>思路</strong>：因为是有序递增的线性表，值相同的元素肯定在连续的位置上。设立一个当前结点指针、一个前驱结点指针。如果当前结点元素值等于其前驱结点元素值，那么删除当前结点，令当前结点的指针向后移动。如果当前结点元素值不等于其前驱结点元素值，那么当前结点指针和前驱结点指针同时向后移动一位</p><p><strong>代码</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表去重</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteDuplicatedElem</span><span class="hljs-params">(singleLinkList&amp; L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!L || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>	&#125;<br><br>	LNode* priorNode = L-&gt;next;<br>	LNode* currentNode = priorNode-&gt;next;<br><br>	<span class="hljs-keyword">while</span> (currentNode)&#123;<br>		 <br>		<span class="hljs-keyword">if</span> (currentNode-&gt;data == priorNode-&gt;data) &#123;<br>			LNode* p = currentNode;<br>			currentNode = currentNode-&gt;next;<br>			priorNode-&gt;next = currentNode;<br>			<span class="hljs-built_in">free</span>(p);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			priorNode = priorNode-&gt;next;<br>			currentNode = priorNode-&gt;next;<br>		&#125;<br><br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-第十三题"><a class="header-anchor" href="#13-第十三题">¶</a>13.第十三题</h4><p><strong>题目</strong>：假设有两个按元素值递增次序排列的线性表，均以单链表形式存储。请编写算法将这两个单链表归并为一个按元素值递减次序排列的单链表，并要求利用原来两个单链表的结点存放归并后的单链表。</p><p><strong>思路</strong>：两个链表已经按元素之升序排列。两个工作指针指向两个链表第一个元素。从第一对元素开始进行比较，将较小的元素头插到新链表，并将该工作指针后移，直到其中一个链表遍历完为止。接下来把仍有剩余元素的链表的元素一个个头插到新链表后面。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 两个升序单链表归并为降序单链表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeListByDesc</span><span class="hljs-params">(singleLinkList LA, singleLinkList LB, singleLinkList&amp; L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!LA || !LB) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表尚未初始化！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isEmpty(LA) &amp;&amp; !isEmpty(LB)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LA单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isEmpty(LA) &amp;&amp; isEmpty(LB)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LB单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	LNode* p = LA-&gt;next;<br>	LNode* q = LB-&gt;next;<br>	LNode* r = L;<br><br>	<span class="hljs-keyword">while</span> (p &amp;&amp; q) &#123;<br>		<span class="hljs-keyword">if</span> (p-&gt;data &lt;= q-&gt;data) &#123;<br>			LNode* afterNode = p-&gt;next;<br>			p-&gt;next = L-&gt;next;<br>			L-&gt;next = p;<br>			p = afterNode;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			LNode* afterNode = q-&gt;next;<br>			q-&gt;next = L-&gt;next;<br>			L-&gt;next = q;<br>			q = afterNode;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// 将 LA 的剩余部分元素一个个头插到 L 中</span><br>	<span class="hljs-keyword">while</span> (p) &#123;<br>		LNode* afterNode = p-&gt;next;<br>		p-&gt;next = L-&gt;next;<br>		L-&gt;next = p;<br>		p = afterNode;<br>	&#125;<br><br>	<span class="hljs-comment">// 将 LB 的剩余部分元素一个个头插到 L 中</span><br>	<span class="hljs-keyword">while</span> (q) &#123;<br>		LNode* node = q-&gt;next;<br>		q-&gt;next = L-&gt;next;<br>		L-&gt;next = q;<br>		q = node;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="14-第十四题"><a class="header-anchor" href="#14-第十四题">¶</a><strong>14</strong>.第十四题</h4><p><strong>题目</strong>：A 和 B 是两个单链表（带头结点），其元素递增有序。设计一个算法从 A 和 B 中的公共元素产生单链表 C，要求不破坏 A、 B的结点。</p><p><strong>思路</strong>：p、q指向A、B两个单链表，为其工作指针。从第一对元素开始比较，如果元素值不同，则值比较小的结点指针向后移动。如果两个元素值相同，则新建一个结点值为该元素值，插入到新链表中</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 取两个链表共同元素建立新链表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">newListByCommonElem</span><span class="hljs-params">(singleLinkList LA, singleLinkList LB, singleLinkList &amp;L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!LA || !LB || !L) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;有单链表尚未初始化！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (isEmpty(LA) || isEmpty(LB)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;两个链表无重复元素！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	LNode* p = LA-&gt;next;<br>	LNode* q = LB-&gt;next;<br>	LNode* r = L;<br><br>	<span class="hljs-keyword">while</span> (p &amp;&amp; q) &#123;<br>		<span class="hljs-keyword">if</span> (p-&gt;data &lt; q-&gt;data) &#123;<br>			p = p-&gt;next;<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;data &gt; q-&gt;data) &#123;<br>			q = q-&gt;next;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			LNode* tempNode = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>			tempNode-&gt;data = p-&gt;data;<br>			r-&gt;next = tempNode;<br>			r = tempNode;<br>			p = p-&gt;next;<br>			q = q-&gt;next;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// 将 L 的末尾指针置空</span><br>	r-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="15-第十五题"><a class="header-anchor" href="#15-第十五题">¶</a>15.第十五题</h4><p><strong>题目</strong>：已知两个链表 A 和 B 分别表示两个集合，其元素递增排序。编写函数，求 A 与 B 的交集，并存放于 A 链表中。</p><p><strong>思路</strong>：同第十四题思路大致相同，仅仅是将最终结果凝聚在了链表 A 上。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将链表 A 和 B 的交集凝聚在 A 中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commonElemList</span><span class="hljs-params">(singleLinkList&amp; A, singleLinkList&amp; B)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!A || !B || isEmpty(A) || isEmpty(B)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;两个链表无交集！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	LNode* p = A-&gt;next;<br>	LNode* q = B-&gt;next;<br>	LNode* r = A;<br><br>	<span class="hljs-keyword">while</span> (p &amp;&amp; q) &#123;<br>		<span class="hljs-keyword">if</span> (p-&gt;data == q-&gt;data) &#123;<br>			r-&gt;next = p;<br>			r = p;<br>			p = p-&gt;next;<br>			q = q-&gt;next;<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;data &lt; q-&gt;data) &#123;<br>			p = p-&gt;next;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			q = q-&gt;next;<br>		&#125;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="16-第十六题"><a class="header-anchor" href="#16-第十六题">¶</a>16.第十六题</h4><p><strong>题目</strong>：两个整数序列 A = a1, a2, a3, …, am 和 B = b1, b2, b3, …, bn已经存入两个单链表中，设计一个算法，判断序列 B 是否为序列 A 的连续子序列。</p><p><strong>思路</strong>：用两个指针来遍历两个单链表，当结点值相同的时候，两个指针同时向后移动，当结点值不相同的时候， <strong>A表的指针继续向后遍历，B表的指针回到头部重新开始遍历</strong>-。最后判断B表是否遍历完毕，如果遍历完毕，则说明 B 表是 A 表的连续子序列，否则不是。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断 B 链表是否为 A 链表的连续子序列</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubList</span><span class="hljs-params">(singleLinkList A, singleLinkList B)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!A || !B) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表未初始化！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125; <br>	<br>	LNode* p = A-&gt;next;<br>	LNode* q = B-&gt;next;<br>	LNode* Bhead = B;<br><br>	<span class="hljs-keyword">while</span> (p &amp;&amp; q) &#123;<br>		<span class="hljs-comment">// 如果数据相同，指针同时向后移动</span><br>		<span class="hljs-keyword">if</span> (p-&gt;data == q-&gt;data) &#123;<br>			p = p-&gt;next;<br>			q = q-&gt;next;<br>		&#125;<br>		<span class="hljs-comment">// 如果数据不同，A 表指针向后移动， B表指针回到第一个结点</span><br>		<span class="hljs-keyword">else</span> &#123;<br>			p = p-&gt;next;<br>			q = Bhead-&gt;next;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// 如果 B 表遍历完了则为 A 连续子序列</span><br>	<span class="hljs-keyword">return</span> q == <span class="hljs-literal">NULL</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="17-第十七题"><a class="header-anchor" href="#17-第十七题">¶</a>17.第十七题</h4><p><strong>题目</strong>：设计一个算法用于判断一个带头结点的循环双链表是否对称。</p><p><strong>思路</strong>：让 p 指针从左向右扫描，q 从右向左扫描，直到它们指向同一结点或者相邻为止。若期间这两个指针指向的结点值相同，则继续进行下去，否则返回 false。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断双向链表是否为对称的</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Symmetry</span><span class="hljs-params">(doubleLinkList L)</span> </span>&#123;<br><br>	DLNode* p = L-&gt;next;<br>	DLNode* q = L-&gt;prior;<br><br>	<span class="hljs-keyword">while</span> (p != q || q-&gt;next != p) &#123;<br>		<span class="hljs-keyword">if</span> (p-&gt;data == q-&gt;data) &#123;<br>			p = p-&gt;next;<br>			q = q-&gt;prior;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="18-第十八题"><a class="header-anchor" href="#18-第十八题">¶</a>18.第十八题</h4><p><strong>题目</strong>：有两个循环单链表,链表头指针分别为 h1 和 h2，编写一个函数将链表 h2 链接到 链表 h1 之后，要求链接之后的链表仍保持循环链表形式。</p><p><strong>思路</strong>：指针 pHead 指向 h1 头结点，指针 qHead 指向 h2 头结点。p 和 q 作为工作指针。首先让 p 指针遍历最后指向 链表 h1 的尾结点，将尾结点的指针指向 qHead-&gt;next。然后让 q 指针遍历指向指向 链表 h2 的尾结点，将尾结点的指针指向 pHead。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(singleLinkList &amp;h1, singleLinkList &amp;h2)</span> </span>&#123;<br>    <br>    LNode* pHead = h1;<br>    LNode* qHead = h2;<br>    LNode* p = h1-&gt;next;<br>    LNode *q = h2-&gt;next;<br>    <br>    <span class="hljs-keyword">while</span>(p-&gt;next) &#123;<br>        p = p-&gt;next;<br>    &#125;<br>    p-&gt;next = qHead-&gt;next;<br>    <br>    <span class="hljs-keyword">while</span>(q-&gt;next) &#123;<br>        q = q-&gt;next;<br>    &#125;<br>    q-&gt;next = pHead;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="19-第十九题"><a class="header-anchor" href="#19-第十九题">¶</a><strong>19</strong>.第十九题</h4><p><strong>题目</strong>：设有一个带头结点的循环单链表，其结点值均为正整数。设计一个算法，反复找出单链表中结点值最小的 结点并输出，然后将该结点从中删除，直到单链表为空为止，再删除表头结点。</p><p><strong>思路</strong>：设置一个循环，仅当 L-&gt;next == L时（循环单链表只剩下头结点）时结束，在循环体内，找到当前单链表最小的结点输出并删除。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delAllNode</span><span class="hljs-params">(singleLinkList &amp;L)</span> </span>&#123;<br>    <br>    LNode *curNod, *priorNode, *minNode, *minPriorNode;<br>    <span class="hljs-keyword">while</span>(L-&gt;next != L) &#123;<br>        <br>        curNode = L-&gt;next;<br>        priorNode = L;<br>        minNode = L-&gt;next;<br>        minPriorNode = L;<br>        <br>        <span class="hljs-keyword">while</span>(curNode) &#123;<br>            <span class="hljs-keyword">if</span>(curNode-&gt;data &gt;= minNode-&gt;data) &#123;<br>                curNode = curNode-&gt;next;<br>                priorNode = priorNode-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                minNode = curNode;<br>                minPriorNode = priorNode;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最小值：%d\n&quot;</span>, minNode-&gt;data);<br>        minPriorNode-&gt;next = minNode-&gt;next;<br>        <span class="hljs-built_in">free</span>(minNode);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(L);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="20-第二十题"><a class="header-anchor" href="#20-第二十题">¶</a>20.第二十题</h4><p><strong>题目</strong>：设头指针为 L 的带有表头结点的非循环双向链表，其每个结点中除有 pred（前驱指针），data（数据）和 next（后继指针）外，还有一个访问频度域 freq。在链表被启用前，其值均被初始化为零。每当在链表中进行一次 Locate(L, x)运算时，令元素值为 x 的结点中 freq 域的值加 1，并使此链表中结点保持按访问频度非增（递减）的顺序排列，同时最近访问的结点排在频度相同的结点前面，以便使频繁访问的结点总是靠近表头。试编写符合上述要求的 Locate(L, x）运算的算法，该运算为函数过程，返回找到结点的地址，类型为指针型。</p><p><strong>思路</strong>：首先在双向链表中查找数据值为 x 的结点，茶道后，将结点从链表上摘下来，然后顺着结点的前驱链查找该结点的插入位置（频度递减，且应排在同频度的第一位，即向前找到第一个比它频度大的结点，插入位置应为该结点之后），并插入到该位置。</p><p><strong>代码</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">DLinkNode* <span class="hljs-title">Locate</span><span class="hljs-params">(DLinkList &amp;L, elemType x)</span> </span>&#123;<br>    <br>    DNode *curNode, *priorNode;<br>    <span class="hljs-keyword">while</span>(curNode &amp;&amp; curNode-&gt;data != x)&#123;<br>        curNode = curNode-&gt;next<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!curNode) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不存在值为 x 的结点！\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 频度域加1</span><br>        curNode-&gt;freq += <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 将 curNode 结点从链表中摘下</span><br>        <span class="hljs-keyword">if</span>(curNode-&gt;next) &#123;<br>            curNode-&gt;next-&gt;prior = curNode-&gt;prior;<br>        &#125;<br>        curNode-&gt;prior-&gt;next = curNode-&gt;next;<br>        <span class="hljs-comment">// 找到待插入的位置前驱结点</span><br>        priorNode = curNode-&gt;prior;<br>        <span class="hljs-keyword">while</span>(curNode-&gt;freq &lt;= priroNode-&gt;freq &amp;&amp; priorNode != L) &#123;<br>            priorNode = priorNode-&gt;prior;<br>        &#125;<br>        <span class="hljs-comment">// 将该结点插入</span><br>        curNode-&gt;next = priorNode-&gt;next;<br>        priorNode-&gt;next-&gt;prior = curNode;<br>        curNode-&gt;prior = priorNode;<br>        priorNode-&gt;next = curNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> curNode;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="21-第二十一题"><a class="header-anchor" href="#21-第二十一题">¶</a>21.第二十一题</h4><p><strong>题目</strong>：已知一个带有表头结点的单链表，结点结构为：|data|link|。</p><p>假设该链表只给除了头指针 list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第 k 个位置上的结点（k 为正整数）。若查找成功，算法输出该结点的 data 域的值，并返回 1；否则，只返回 0.要求：</p><p>1）描述算法的基本设计思想</p><p>2）描述算法的详细实现步骤</p><p>3）根据设计思想和实现步骤，采用程序设计语言描述算法，关键之处给出简要注释。</p><p><strong>思路</strong>：首先计算链表的长度 length，如果 k &gt;length 则直接返回 0，否则只需要查找第 length - k个 结点即可。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 查找倒数第 k 个元素</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findLastButKElem</span><span class="hljs-params">(singleLinkList L, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!L || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br> 	LNode* curNode = L-&gt;next;<br>	<span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(curNode) &#123;<br>		length++;<br>		curNode = curNode-&gt;next;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (k &gt; length || k &lt;= <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查找元素倒数位序不合法！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">int</span> cnt = length - k + <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>	curNode = L-&gt;next;<br>	<span class="hljs-keyword">while</span> (i &lt; cnt) &#123;<br>		i++;<br>		curNode = curNode-&gt;next;<br>	&#125;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;倒数第%d个位置的元素值为：%d&quot;</span>, k, curNode-&gt;data);<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="22-第二十二题"><a class="header-anchor" href="#22-第二十二题">¶</a>22.第二十二题</h4><p><strong>题目</strong>：假定采用带头结点的单链表存储单词，当两个单词有相同的后缀时，可共享相同的后缀存储空间，例如“loading” 和 “being” 的存储映像如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/3.png" srcset="/img/loading.gif" alt="共享后缀存储空间"></p><p>设 str1 和 str2 分别指向两个单词所在的单链表的头结点，链表结点结构为 data 和 next，请设计一个时间上尽可能的高效算法，找出由 str1 和 str2 所指向的两个链表共同后缀的起始位置。要求：</p><p>1）给出算法的基本设计思想</p><p>2）根据设计思想，采用程序语言描述算法</p><p>3）说明你所设计算法的时间复杂度</p><p><strong>思路</strong>：本题类似于第八题两个链表求第一个公共结点。思路也类似，选取其中一个即可。计算出 str1和 str2的长度 m 和 n，哪一个大，就让那个长度对应的单链表指针先走 |m - n|步，然后一直同步向后走，直到找到第一个相同的点。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求取两个单链表个公共结点2</span><br><span class="hljs-function">LNode* <span class="hljs-title">findCommonNode</span><span class="hljs-params">(singleLinkList str1, singleLinkList str2)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!str1 || !str2 || !str1-&gt;next || !str2-&gt;next) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;两个单链表无公共结点！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">int</span> str1Length = getLength(str1);<br>	<span class="hljs-keyword">int</span> str2Length = getLength(str2);<br>	<span class="hljs-comment">// 求两个单链表的长度差值</span><br>	<span class="hljs-keyword">int</span> lengthDiff;<br>	LNode* longListHead;<br>	LNode* shortListHead;<br><br>	<span class="hljs-comment">// 确定指针指向</span><br>	<span class="hljs-keyword">if</span> (str1Length &gt; str2Length) &#123;<br>		lengthDiff = str1Length - str2Length;<br>		longListHead = str1;<br>		shortListHead = str2;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		lengthDiff = str1Length - str2Length;<br>		longListHead = str2;<br>		shortListHead = str1;<br>	&#125;<br><br>	<span class="hljs-comment">// 先对长链表进行移动，移动到与锻炼表长度相同的位置</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lengthDiff; i++) &#123;<br>		longListHead = longListHead-&gt;next;<br>	&#125;<br><br>	<span class="hljs-comment">// 寻找公共结点</span><br>	<span class="hljs-keyword">while</span> (longListHead != <span class="hljs-literal">NULL</span> &amp;&amp; shortListHead != <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">if</span> (longListHead == shortListHead) &#123;<br>			<span class="hljs-keyword">return</span> longListHead;<br>		&#125;<br>		longListHead = longListHead-&gt;next;<br>		shortListHead = shortListHead-&gt;next;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：时间复杂度为O(m+n)或者O(max(m, n))</p><h4 id="23-第二十三题"><a class="header-anchor" href="#23-第二十三题">¶</a>23.第二十三题</h4><p><strong>题目</strong>：用单链表保存 m 个整数，结点的结构为|data|link|，且|data| &lt;= n（n 为正整数）。现要求设计一个时间复杂度尽可能高效的算法，对于链表中 data 的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如，给定的单链表 head 如下：</p><p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/4.png" srcset="/img/loading.gif" alt="删除绝对值相等结点"></p><p>要求：</p><p>1）给出算法的基本设计思想</p><p>2）使用 C 或 C++ 语言，给出单链表结点的数据类型定义</p><p>3）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释</p><p>4）说明你所设计算法的时间复杂度和空间复杂度。</p><p><strong>思路</strong>：创建大小为 n 的数组 A，从链表第一个结点开始遍历，查看以结点的元素值data绝对值为下标的数组元素值是否为0，如果为0，将A[data] 设置为1。如果后面遇到以data的绝对值的为下标的数组元素值为 1， 直接删除该结点即可。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 只留下绝对值不同的结点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(singleLinkList&amp; L, elemType n)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!L || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 创建大小为 n 数组</span><br>	elemType* A = (elemType*)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(elemType));<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>		A[i] = <span class="hljs-number">0</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">// 工作指针和其前驱指针</span><br>	LNode* curNode = L-&gt;next;<br>	LNode* priorNode = L;<br><br>	<span class="hljs-keyword">while</span> (curNode) &#123;<br><br>		<span class="hljs-comment">// 绝对值首次出现？</span><br>		<span class="hljs-keyword">if</span> (A[<span class="hljs-built_in">abs</span>(curNode-&gt;data)] == <span class="hljs-number">0</span>) &#123;<br>			A[<span class="hljs-built_in">abs</span>(curNode-&gt;data)] = <span class="hljs-number">1</span>;<br>			curNode = curNode-&gt;next;<br>			priorNode = priorNode-&gt;next;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			LNode* temp = curNode;<br>			curNode = curNode-&gt;next;<br>			priorNode-&gt;next = curNode;<br>			<span class="hljs-built_in">free</span>(temp);<br>		&#125;<br><br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="24-第二十四题"><a class="header-anchor" href="#24-第二十四题">¶</a>24.第二十四题</h4><p><strong>题目</strong>：设计一个算法完成以下功能：判断一个链表是否有环，如果有，找到环的入口点并返回，否则返回 NULL。</p><p><strong>思路</strong>：参考博客：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ef71e04241e4">数据结构面试 之 单链表是否有环及环入口点 附有最详细明了的图解 - 简书 (jianshu.com)</a></p><p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Sz411i7sS">算法面试2leetcode链表环入口节点代码实现_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><p><strong>如何判断是否有环？</strong></p><p>首先创建两个指针 1 和 2，同时同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针1每次向下移动一个节点，让指针2每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同且快指针指向的结点不为NULL，则判断出链表有环，如果不同，则继续下一次循环。</p><p>例如链表A-&gt;B-&gt;C-&gt;D-&gt;B-&gt;C-&gt;D，两个指针最初都指向节点A，进入第一轮循环，指针1移动到了节点B，指针2移动到了C。第二轮循环，指针1移动到了节点C，指针2移动到了节点B。第三轮循环，指针1移动到了节点D，指针2移动到了节点D，此时两指针指向同一节点，判断出链表有环。</p><p>此方法也可以用一个更生动的例子来形容：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过，原因很简单，因为跑道是环形的。</p><p><strong>那么如何找到有环链表的入环点？</strong></p><p>那么，知道了链表有环之后，如何找到环的入口点呢？</p><img src="https://cdn.jsdelivr.net/gh/AtroxQW/jsDeliverCDN/source/_posts/链表及其基本操作的实现/5.png" srcset="/img/loading.gif" alt="寻找环的入口点" style="zoom:80%"><p>在这里，我们不再需要快慢指针。假设p1、p2两个指针即可。让 p2 领先 p1 n步，这里的 n 步的数量就是环内结点的个数。如图上所示，环内结点为 6 个，则 p2 比 p1 领先 6 步。那么，我们如何获得这个步数 n 呢？这时候就需要我们判断是否有环时的操作。慢指针走 1 步，快指针走 2 步，每走一次，计数器加 1。当他们相遇时，计数器的数目就是 n 的大小。这时候，只需要将 p1 指向第一个结点，将 p2 指向 它们第一次相遇的点即可。然后二者同时向后遍历，当两指针相等时，它们指向的结点就是环的入口结点。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断一个单链表是否有环，并找到环的入口</span><br><span class="hljs-function">LNode* <span class="hljs-title">findLoopStartNode</span><span class="hljs-params">(singleLinkList L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!L || isEmpty)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	LNode* fast = L-&gt;next, * slow = L-&gt;next;<br>	<br>	<span class="hljs-keyword">while</span> (fast-&gt;next &amp;&amp; slow) &#123;<br>		slow = slow-&gt;next;<br>		fast = fast-&gt;next-&gt;next;<br>		<span class="hljs-keyword">if</span> (slow == fast)<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">// 无环</span><br>	<span class="hljs-keyword">if</span> (!slow || !fast-&gt;next) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// p1 指向第一个结点， p2 指向相遇结点</span><br>	LNode* p1 = L-&gt;next, * p2 = slow;<br>	<span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>		p1 = p1-&gt;next;<br>		p2 = p2-&gt;next;<br>	&#125;<br><br>	<span class="hljs-comment">// 环的入口点</span><br>	<span class="hljs-keyword">return</span> p1;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="25-第二十五题"><a class="header-anchor" href="#25-第二十五题">¶</a>25.第二十五题</h4><p><strong>题目</strong>：设线性表 L = (a1, a2, a3, …, an-2, an-1, an)采用带头结点的单链表保存，链表中的结点定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125;NODE;<br></code></pre></td></tr></table></figure><p>请设计一个空间复杂度为 O(1) 且时间上尽可能高效的算法，重新排列 L 中的各结点，得到线性表 L’ = (a1, an, a2, an-1, a3, an-2,…)，要求：</p><p>1）给出算法的基本设计思想</p><p>2）根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释</p><p>3）说明你所设计W·的算法的时间复杂度</p><p><strong>思路</strong>：</p><ol><li>寻找中间结点， p 移动一个结点， q 移动两个结点，当 q 移动到最后时候， p 指向中间结点。</li><li>让 q 指向 p-&gt;next， 即链表的后半部分。</li><li>将后半部分原地逆置。</li><li>按要求重新排列。</li></ol><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 重排单链表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resortList</span><span class="hljs-params">(singleLinkList&amp; L)</span> </span>&#123;<br><br>	<span class="hljs-keyword">if</span> (!L || isEmpty(L)) &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;单链表为空！\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 找到中间结点</span><br>	LNode* p = L-&gt;next;<br>	LNode* q = L-&gt;next;<br>	<span class="hljs-keyword">while</span> (q-&gt;next) &#123;<br>		p = p-&gt;next;<br>		q = q-&gt;next;<br>		<span class="hljs-keyword">if</span> (q-&gt;next) &#123;<br>			q = q-&gt;next;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// q 指向后半部分结点开始结点</span><br>	q = p-&gt;next;<br>	<span class="hljs-comment">// 将后半部分单链表就地逆置</span><br>	LNode* curNode = q;<br>	p-&gt;next = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-comment">// 头插法实现后半部分链表就地逆置</span><br>	<span class="hljs-keyword">while</span> (curNode)&#123;<br>		LNode* nextNode = curNode-&gt;next;<br>		curNode-&gt;next = p-&gt;next;<br>		p-&gt;next = curNode;<br>		curNode = nextNode;<br>	&#125;<br>	q = p-&gt;next;<br>	p-&gt;next = <span class="hljs-literal">NULL</span>;<br>	p = L-&gt;next;<br><br>	<span class="hljs-comment">// 重排单链表</span><br>	<span class="hljs-keyword">while</span> (q) &#123;<br>		LNode* nextNode = q-&gt;next;<br>		q-&gt;next = p-&gt;next;<br>		p-&gt;next = q;<br>		p = q-&gt;next;<br>		q = nextNode;<br>	&#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="全部代码"><a class="header-anchor" href="#全部代码">¶</a>全部代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas mb-3"><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/DataStructure/">DataStructure</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/posts/2021/03/23/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/"><span class="hidden-mobile">顺序表及其基本操作的实现</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><div id="gitalk-container"></div><script type="text/javascript">Fluid.utils.waitElementVisible("gitalk-container",(function(){Fluid.utils.createCssLink("/css/gitalk.css"),Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.min.js",(function(){new Gitalk({clientID:"af550312a411b96c64b9",clientSecret:"f11934265fd18324cb2d9fd605d7d445207a3e52",repo:"gitalk",owner:"AtroxQW",admin:["AtroxQW"],id:"28f6e67d958b4f0ea9663884a063bcf5",language:"zh-CN",labels:["Gitalk"],perPage:10,pagerDirection:"last",createIssueManually:!0,distractionFreeMode:!1}).render("gitalk-container")}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>document.querySelector("#local-search-input").onclick=function(){searchFunc("/local-search.xml","local-search-input","local-search-result"),this.onclick=null}</script><script src="/js/boot.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://libs.xiaoz.top/instantclick/instantclick.min.js" data-no-instant></script><script data-no-instant>InstantClick.init()</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>