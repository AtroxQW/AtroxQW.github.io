<!DOCTYPE html><html lang="en" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="codeAtrox"><meta name="keywords" content=""><title>SpringBoot笔记02-运行原理深入浅出 - Atrox的博客</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,onlypost:!1},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"ESDyAFj0rlPHtdaIfJoa3pTr-gzGzoHsz",app_key:"j9txoPTCSqfLMGi1UmkNO3vV",server_url:"AtroxQW.github.io"}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>AtroxQW</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于我</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/bg/atrox1.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="SpringBoot笔记02-运行原理深入浅出"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-01-07 11:44" pubdate>January 7, 2021 am</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 61 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">SpringBoot笔记02-运行原理深入浅出</h1><div class="markdown-body"><h1 id="运行原理深入浅出"><a href="#运行原理深入浅出" class="headerlink" title="运行原理深入浅出"></a>运行原理深入浅出</h1><hr><blockquote><p>我们之前写的SpringBoot项目，到底是如何运行的呢？既然它是一个Maven项目，我们从<code>pom.xml</code>文件开始探究。</p></blockquote><hr><h2 id="pom文件解析"><a href="#pom文件解析" class="headerlink" title="pom文件解析"></a>pom文件解析</h2><h3 id="一、父依赖"><a href="#一、父依赖" class="headerlink" title="一、父依赖"></a>一、父依赖</h3><p>在pom.xml中，有<parent></parent>标签，表示它是有父项目<code>spring-boot-starter-parent.xml</code>的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们点击该该父项目，进入<code>spring-boot-starter-parent.xml</code>，它主要是管理项目的资源过滤和插件。在它里面，还是依赖于一个父项目<code>spring-boot-dependencies.xml</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里就是真正管理SpringBoot应用中所有依赖版本的文件，是SpringBoot的版本控制中心。</p><p><strong>我们之后导入依赖是默认不需要写版本的，但如果导入的包在没有在版本控制中心管理着就需要手动配置版本。</strong></p><h3 id="二、启动器"><a href="#二、启动器" class="headerlink" title="二、启动器"></a>二、启动器</h3><p>我们这里说的启动器是<code>spring-boot-starter</code>，在pom文件中以依赖形式存在。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--默认的启动器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--web启动器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>spring-boot-starter-xxx</strong>：spring-boot的场景启动器。例如<strong>spring-boot-starter-web</strong>，它帮我们导入了web项目正常运行所依赖的所有包。</p><p>SpringBoot将所有的功能场景都抽取了出来，做成一个个的starter（启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 。我们未来也可以自己自定义 starter。</p><p>具体参考的启动器在官网有说明：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</a></p><hr><blockquote><p>分析完pom.xml后我们来看看主启动类有什么名堂。</p></blockquote><hr><h2 id="主启动类解析"><a href="#主启动类解析" class="headerlink" title="主启动类解析"></a>主启动类解析</h2><h3 id="一、默认的主启动类"><a href="#一、默认的主启动类" class="headerlink" title="一、默认的主启动类"></a>一、默认的主启动类</h3><p>默认主启动类的内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@SpringBootApplication 来标注一个主程序类</span><br><span class="hljs-comment">//说明这是一个Spring Boot应用</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootApplication</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     <span class="hljs-comment">//以为是启动了一个方法，没想到启动了一个服务</span><br>      SpringApplication.run(SpringbootApplication.class, args);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是<strong>一个简单的启动类并不简单！</strong>我们来分析一下这些注解都干了什么.</p><h3 id="二、-SpringBootApplication—项目的基石"><a href="#二、-SpringBootApplication—项目的基石" class="headerlink" title="二、@SpringBootApplication—项目的基石"></a>二、@SpringBootApplication—项目的基石</h3><p>@SpringBootApplication的作用是：<strong>标注在某个类上说明这个类为SpringBoot的主启动类</strong>，SpringBoot需要运行这个类的main方法来启动项目。</p><p>进入这个注解，我们观察到下面的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123;</span><br><span class="hljs-meta">  @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">  @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br>   ......<br>&#125;<br></code></pre></td></tr></table></figure><p>在其中 <strong>@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan</strong>是我们所关心的3个注解，下面是官网上对它们的解释：</p><ul><li><p>@SpringBootConfiguration：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</p></li><li><p>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</p></li><li><p>@ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。</p></li></ul><p>下面，我们将对这三个注解底层进行详细探究。</p><h3 id="三、-ComponentScan—扫描包下被装配的类"><a href="#三、-ComponentScan—扫描包下被装配的类" class="headerlink" title="三、@ComponentScan—扫描包下被装配的类"></a>三、@ComponentScan—扫描包下被装配的类</h3><p>使用过 spring 框架的小伙伴都知道，spring中有4个注解可以<strong>定义一个 bean</strong> ，分别是<code>@Service</code>，<code>@Repository</code>，<code>@Component</code>，<code>@Controller</code>。而<code>@Component</code>注解就是用来自动扫描被这些注解标识的类，最终<strong>生成 IOC 容器中的 bean</strong>。</p><p>在<code>@Component</code>中，可以通过设置basePackages，includeFilters，excludeFilters属性来<strong>动态确定自动扫描范围</strong>。默认情况下，它扫描上面的所有的类型，并且扫描范围是<code>@Component</code>注解所在配置类（即默认的主启动类）的<strong>同级目录的类即该目录下的所有子目录的类</strong>。</p><p>所以，使用<code>@SpringBootApplication</code>注解，就说明我们使用了<code>@ComponentScan</code>的默认配置，我们建议把使用<code>@SpringBootApplication</code>注解的类放置在 root package下，其他类都放置在 root package的子包里面，这样 bean 就不会被遗漏扫描。</p><h3 id="四、-SpringBootConfiguration—声明配置类"><a href="#四、-SpringBootConfiguration—声明配置类" class="headerlink" title="四、@SpringBootConfiguration—声明配置类"></a>四、@SpringBootConfiguration—声明配置类</h3><p>这个注解的作用和<code>@Configuration</code>的作用基本相同，其实点进<code>@SpringBootConfiguration</code>里面，它也是一个<code>@Configuration</code>，标注在某个类上，表示这是一个SpringBoot的配置类，配置类对应着可以替换Spring的xml配置文件，被注解的类内部包含一个或多个<code>@Bean</code>注解方法，用于构建bean定义以及初始化Spring容器。</p><h3 id="五、-EnableAutoConfiguration—自动装配"><a href="#五、-EnableAutoConfiguration—自动装配" class="headerlink" title="五、@EnableAutoConfiguration—自动装配"></a>五、@EnableAutoConfiguration—自动装配</h3><p>在这里我们一步步的由浅入深点进注解和方法查看它的运行原理，下面的目录仅代表目录结构。</p><h4 id="1-EnableAutoConfiguration：开启自动配置功能"><a href="#1-EnableAutoConfiguration：开启自动配置功能" class="headerlink" title="1. @EnableAutoConfiguration：开启自动配置功能"></a><strong>1. @EnableAutoConfiguration：开启自动配置功能</strong></h4><p>之前我们需要自己配置的东西，而现在SpringBoot可以帮我们自动配置。@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效。点击进入注解继续查看发现有下面的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>1.1 @AutoConfigurationPackage：自动配置包</strong></p></li><li><p><strong>1.2 @Import(AutoConfigurationImportSelector.class)：给容器导入组件</strong></p></li></ul><p>为了不让结构变得更混乱，我们把1.1和1.2提出来当做2和3来分析。</p><h4 id="2-AutoConfigurationPackage：自动配置包"><a href="#2-AutoConfigurationPackage：自动配置包" class="headerlink" title="2. @AutoConfigurationPackage：自动配置包"></a><strong>2. @AutoConfigurationPackage：自动配置包</strong></h4><p>​</p><p>在这个注解中，我们可以看到这样的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Import(AutoConfigurationPackages.Registrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，它导入了AutoConfigurationPackages.Registrar.class，字面意思为自动注册类。而Registrar.class的作用是：<strong>将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器</strong> 。</p><p><strong>我们点进Registrar这个类来看一看</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span>, <span class="hljs-title">DeterminableImports</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>        register(registry, <span class="hljs-keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title">determineImports</span><span class="hljs-params">(AnnotationMetadata metadata)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-keyword">new</span> PackageImports(metadata));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们重点看一下<code>registerBeanDefinitions()</code>方法。方法的第二个参数通过<code>new PackageImports(metadata).getPackageNames()</code>的方法来赋值。</p><p>这里我们看一下<code>PackageImports类</code>的构造器方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">PackageImports(AnnotationMetadata metadata) &#123;<br>    AnnotationAttributes attributes = AnnotationAttributes<br>        .fromMap(metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), <span class="hljs-keyword">false</span>));<br>    List&lt;String&gt; packageNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(attributes.getStringArray(<span class="hljs-string">&quot;basePackages&quot;</span>)));<br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; basePackageClass : attributes.getClassArray(<span class="hljs-string">&quot;basePackageClasses&quot;</span>)) &#123;<br>        packageNames.add(basePackageClass.getPackage().getName());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (packageNames.isEmpty()) &#123;<br>        packageNames.add(ClassUtils.getPackageName(metadata.getClassName()));<br>    &#125;<br>    <span class="hljs-keyword">this</span>.packageNames = Collections.unmodifiableList(packageNames);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>metadata：实际上是StandardAnnotationMetadata的实例。</p></li><li><p>metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), false)：这个方法获取了标注<code>@AutoConfigurationPackage</code>注解的类的全限定名</p></li><li><p>packageNames.add(basePackageClass.getPackage().getName())：这个方法获取了其所在的包名。</p></li></ul><p>然后，看这个<code>Registrar</code>类中的<code>register()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(BeanDefinitionRegistry registry, String... packageNames)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (registry.containsBeanDefinition(BEAN)) &#123;<br>        BasePackagesBeanDefinition beanDefinition = (BasePackagesBeanDefinition) registry.getBeanDefinition(BEAN);<br>        beanDefinition.addBasePackages(packageNames);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        registry.registerBeanDefinition(BEAN, <span class="hljs-keyword">new</span> BasePackagesBeanDefinition(packageNames));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们走else的逻辑，其实就是构建了一个实例，进行注册。</p><h4 id="3-Import-AutoConfigurationImportSelector-class-：给容器导入组件"><a href="#3-Import-AutoConfigurationImportSelector-class-：给容器导入组件" class="headerlink" title="3. @Import(AutoConfigurationImportSelector.class)：给容器导入组件"></a>3. @Import(AutoConfigurationImportSelector.class)：给容器导入组件</h4><p>我们首先看这里的<code>AutoConfigurationImportSelector</code>，它是一个自动配置导入选择器，那么它会导入哪些组件的选择器呢？</p><p><strong>我们点进AutoConfigurationImportSelector这个类看一看</strong>：</p><ol><li><p>类中有这样的一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;<br>    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),<br>                                                                         getBeanClassLoader());<br>    Assert.notEmpty(configurations, <span class="hljs-string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span><br>                    + <span class="hljs-string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);<br>    <span class="hljs-keyword">return</span> configurations;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这里的<code>getSpringFactoriesLoaderFactoryClass</code>方法，返回的就是我们最开始看到启动类自动导入配置的注解类：<code>EnableAutoConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;<br>    <span class="hljs-keyword">return</span> EnableAutoConfiguration.class;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>这个方法还调用了<code>SpringFactoriesLoader</code>类的静态方法，我们进入SpringFactoriesLoader类loadFactoryNames() 方法。</p><ol start="2"><li><p><strong>loadFactoryNames方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryType, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>    ClassLoader classLoaderToUse = classLoader;<br>    <span class="hljs-keyword">if</span> (classLoaderToUse == <span class="hljs-keyword">null</span>) &#123;<br>        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();<br>    &#125;<br>    String factoryTypeName = factoryType.getName();<br>    <span class="hljs-keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>​ 在这里，此方法调用了又调用了<code>loadSpringFactories</code>方法，我们依旧继续点击查看。</p><ol start="3"><li><p><strong>loadSpringFactories方法内容如下</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;<br>    Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);<br>        <span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;<br>            URL url = urls.nextElement();<br>            UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);<br>            Properties properties = PropertiesLoaderUtils.loadProperties(resource);<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;<br>                String factoryTypeName = ((String) entry.getKey()).trim();<br>                String[] factoryImplementationNames =<br>                    StringUtils.commaDelimitedListToStringArray((String) entry.getValue());<br>                <span class="hljs-keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;<br>                    result.computeIfAbsent(factoryTypeName, key -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;())<br>                        .add(factoryImplementationName.trim());<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Replace all lists with unmodifiable lists containing unique elements</span><br>        result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()<br>                          .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));<br>        cache.put(classLoader, result);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unable to load factories from location [&quot;</span> +<br>                                           FACTORIES_RESOURCE_LOCATION + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>在try语句块内，<code>classLoader.getResources(FACTORIES_RESOURCE_LOCATION)</code>首选是获取了一个资源名为：<code>FACTORIES_RESOURCE_LOCATION</code>的文件。而后将读取到的资源进行遍历，封装成一个Properties文件供我们使用。</li></ol><p>​ <strong>点击这个<code>FACTORIES_RESOURCE_LOCATION</code>，我们查到了它的文件名：spring.factories</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>;<br></code></pre></td></tr></table></figure></li></ol><p>我们全局搜索这个<strong>spring.factories</strong>，找到了它的源头在一个jar包下，我们打开它。看到了很多自动配置的文件；这就是自动配置根源所在！</p><p><img src="/posts/2021/01/07/SpringBoot%E7%AC%94%E8%AE%B002-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/spring_factories.png" srcset="/img/loading.gif" alt="spring.factories文件"></p><h4 id="4-结论"><a href="#4-结论" class="headerlink" title="4.结论"></a>4.结论</h4><ol><li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li><li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li><li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li><li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li><li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li></ol><hr><blockquote><p>下面，我们探究一下主启动类是如何运行的</p></blockquote><hr><h2 id="主启动类运行解析"><a href="#主启动类运行解析" class="headerlink" title="主启动类运行解析"></a>主启动类运行解析</h2><p><code>SpringApplication</code>类用于引导和启动一个Spring应用程序（即SpringBoot开发的应用）。通常用SpringBoot开发一个应用时，在主类的main函数中可以通过如下代码启动一个Spring应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 标注这个类是一个springboot的应用</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot01HelloworldApplication</span> </span>&#123;<br>    <span class="hljs-comment">// 将springboot应用启动</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Springboot01HelloworldApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SpringApplication的静态方法<code>run(Class&lt;?&gt; primarySource, String... args)</code>的第一个参数接受一个Spring容器配置类，第二个参数是命令行参数。将命令行参数转发给SpringApplication类，就可以在用java命令启动应用时，通过命令行参数对Spring应用做一些配置。</p><p>在SpringApplication.run方法中，分析分为两部分，一部分是SpringApplication的实例化，另一部分是run方法的执行。</p><h3 id="一、构建SpringApplication实例"><a href="#一、构建SpringApplication实例" class="headerlink" title="一、构建SpringApplication实例"></a>一、构建SpringApplication实例</h3><p>下面是SpringApplication类静态run方法的源码。可以看到，当我们调用这个静态run方法时，实际上会<strong>构造一个SpringApplication实例</strong>，然后再调用该实例的run方法完成项目的启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> Class[]&#123;primarySource&#125;, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是SpringApplication的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.sources = <span class="hljs-keyword">new</span> LinkedHashSet();<br>    <span class="hljs-keyword">this</span>.bannerMode = Mode.CONSOLE;<br>    <span class="hljs-keyword">this</span>.logStartupInfo = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">this</span>.addCommandLineProperties = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">this</span>.addConversionService = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">this</span>.headless = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">this</span>.registerShutdownHook = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">this</span>.additionalProfiles = Collections.emptySet();<br>    <span class="hljs-keyword">this</span>.isCustomEnvironment = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">this</span>.lazyInitialization = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">this</span>.applicationContextFactory = ApplicationContextFactory.DEFAULT;<br>    <span class="hljs-keyword">this</span>.applicationStartup = ApplicationStartup.DEFAULT;<br>    <span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;<br>    Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>    <span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet(Arrays.asList(primarySources));<br>    <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>    <span class="hljs-keyword">this</span>.bootstrappers = <span class="hljs-keyword">new</span> ArrayList(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances(Bootstrapper.class));<br>    <span class="hljs-keyword">this</span>.setInitializers(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>    <span class="hljs-keyword">this</span>.setListeners(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));<br>    <span class="hljs-keyword">this</span>.mainApplicationClass = <span class="hljs-keyword">this</span>.deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure><p>它主要完成下面的初始化工作：</p><ul><li><p>初始化Spring容器的配置类<strong>primarySources</strong></p></li><li><p><strong>推断应用程序的类型</strong>（webApplicationType），进而根据应用程序的类型创建恰当的ApplicationContext</p></li><li><p>初始化指定的<strong>ApplicaitonContextInitializer</strong>列表</p></li><li><p>初始化所有<strong>可用程序的监听器（ApplicationListener）</strong>列表</p></li><li><p>推断并设置 main 方法的定义类</p></li></ul><p>下面，我们对这些初始化过程进行一一说明。</p><ol><li><p><strong>spring容器配置</strong></p><p>SpringApplication能够从各种不同的配置源读取 bean 的定义。SpringBoot 建议采用 Java 注解配置的方式<strong>提供一个全局唯一的配置类</strong>。但是，我们可以同时使用多种不同的配置源。如果是Java注解的配置方式，会使用<code>AnnotatedBeanDefinitionReader</code>加载配置（通过全类名）。如果是 XML 的配置方式，则会使用 <code>XmlBeanDefinitionReader</code>加载配置（通过 XML 文件地址）。</p></li></ol><ol start="2"><li><p><strong>推断应用程序类型</strong></p><p>SpringApplication默认的应用类型有三种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">WebApplicationType</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	非web类应用，无需内嵌web server</span><br><span class="hljs-comment">    */</span><br>    NONE,<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	servlet类型的web应用，需要启动内嵌的web server</span><br><span class="hljs-comment">    */</span><br>    SERVLET,<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	reactive类型的web应用，需要启动内嵌的reactive web server</span><br><span class="hljs-comment">    */</span><br>    REACTIVE;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>判断的逻辑也比较简单，就是检查 classpath 下是否存在对应的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> WebApplicationType <span class="hljs-title">deduceFromClasspath</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ClassUtils.isPresent(<span class="hljs-string">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>, (ClassLoader)<span class="hljs-keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(<span class="hljs-string">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>, (ClassLoader)<span class="hljs-keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(<span class="hljs-string">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>, (ClassLoader)<span class="hljs-keyword">null</span>)) &#123;<br>        <span class="hljs-keyword">return</span> REACTIVE;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        String[] var0 = SERVLET_INDICATOR_CLASSES;<br>        <span class="hljs-keyword">int</span> var1 = var0.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var2 = <span class="hljs-number">0</span>; var2 &lt; var1; ++var2) &#123;<br>            String className = var0[var2];<br>            <span class="hljs-keyword">if</span> (!ClassUtils.isPresent(className, (ClassLoader)<span class="hljs-keyword">null</span>)) &#123;<br>                <span class="hljs-keyword">return</span> NONE;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> SERVLET;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果 classpath 下存在<code>org.springframework.web.reactive.DispatcherHandler</code>类，则应用类型是REACTIVE</li><li>如果 classpath 下存在<code>org.springframework.web.servlet.DispatcherServlet</code>类，则应用类型是SERVLET</li><li>如果上面两个 DispatcherServlet 类都不存在，则应用类型是NONE</li></ul></li></ol><p>应用类型直接决定了要创建的 ApplicationContext 类型，下表整理了三种应用类型和所创建的 ApplicationContext 类型之间的对应关系。</p><table><thead><tr><th>应用类型</th><th>ApplicationContext类型</th></tr></thead><tbody><tr><td>NONE</td><td>AnnotationConfigApplicationContext</td></tr><tr><td>SERVLET</td><td>AnnotationConfigServletWebServerApplicationContext</td></tr><tr><td>REACTIVE</td><td>AnnotationConfigReactiveWebServerApplicationContext</td></tr></tbody></table><ol start="3"><li><p><strong>初始化 ApplicationContextInitializer &amp; ApplicationListener</strong></p><p>初始化 ApplicaitonContextInitializer 和 ApplicationListener 的过程比较相似，都是借助于 SpringFactoriesLoader 的方式完成初始化的，所以放到一起分析。</p><p>SpringFactoriesLoader 会 读取 META-INF/spring.factories 文件中的配置。一个工程项目中可以同时有多个 META-INF/spring.factories 文件。</p><p>例如，在 <code>spring-boot-autoconfigure</code>jar 包的 META-INF/spring.factories 文件中，有针对 <code>ApplicationContextInitializer</code> 和 <code>ApplicationListeners</code>的配置。</p><ul><li><p><strong>针对ApplicationContextInitializer 的配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># Initializers<br>org.springframework.context.ApplicationContextInitializer=\<br>org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\<br>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener<br></code></pre></td></tr></table></figure></li><li><p><strong>针对于ApplicationListener的配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"># Application Listeners<br>org.springframework.context.ApplicationListener=\<br>org.springframework.boot.ClearCachesApplicationListener,\<br>org.springframework.boot.builder.ParentContextCloserApplicationListener,\<br>org.springframework.boot.context.FileEncodingApplicationListener,\<br>org.springframework.boot.context.config.AnsiOutputApplicationListener,\<br>org.springframework.boot.context.config.DelegatingApplicationListener,\<br>org.springframework.boot.context.logging.LoggingApplicationListener,\<br>org.springframework.boot.env.EnvironmentPostProcessorApplicationListener,\<br>org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener<br></code></pre></td></tr></table></figure></li></ul></li></ol><ol start="4"><li><p><strong>推断主类</strong></p><p>推断主类过程的实现方式很巧妙，通过<strong>遍历异常堆栈</strong>找到方法名为main的类，将其作为主启动类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        StackTraceElement[] stackTrace = (<span class="hljs-keyword">new</span> RuntimeException()).getStackTrace();<br>        StackTraceElement[] var2 = stackTrace;<br>        <span class="hljs-keyword">int</span> var3 = stackTrace.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var4 = <span class="hljs-number">0</span>; var4 &lt; var3; ++var4) &#123;<br>            StackTraceElement stackTraceElement = var2[var4];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;main&quot;</span>.equals(stackTraceElement.getMethodName())) &#123;<br>                <span class="hljs-keyword">return</span> Class.forName(stackTraceElement.getClassName());<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var6) &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="二、run方法运行阶段"><a href="#二、run方法运行阶段" class="headerlink" title="二、run方法运行阶段"></a>二、run方法运行阶段</h3><p>在完成对<code>SpringApplication</code>对象的构建和实例化后，就开始执行 run 方法了。具体代码如下所示，下面将探究其执行过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>    StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();<br>    stopWatch.start();<br>    DefaultBootstrapContext bootstrapContext = createBootstrapContext();<br>    ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;<br>    configureHeadlessProperty();<br>    SpringApplicationRunListeners listeners = getRunListeners(args);<br>    listeners.starting(bootstrapContext, <span class="hljs-keyword">this</span>.mainApplicationClass);<br>    <span class="hljs-keyword">try</span> &#123;<br>        ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);<br>        ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>        configureIgnoreBeanInfo(environment);<br>        Banner printedBanner = printBanner(environment);<br>        context = createApplicationContext();<br>        context.setApplicationStartup(<span class="hljs-keyword">this</span>.applicationStartup);<br>        prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>        refreshContext(context);<br>        afterRefresh(context, applicationArguments);<br>        stopWatch.stop();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br>            <span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);<br>        &#125;<br>        listeners.started(context);<br>        callRunners(context, applicationArguments);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        handleRunFailure(context, ex, listeners);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        listeners.running(context);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        handleRunFailure(context, ex, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>第一准备阶段</p></blockquote><ul><li><p>方法执行伊始，会<strong>先创建和启动一个 <code>StopWatch</code> 对象</strong>，作为计时器。该对象用于统计应用的启动时间。下图中的启动事件日志就是根据 <code>StopWatch</code>对象统计的数据打印的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();<br>stopWatch.start();<br></code></pre></td></tr></table></figure><img src="/posts/2021/01/07/SpringBoot%E7%AC%94%E8%AE%B002-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/stop_watch.png" srcset="/img/loading.gif" alt="应用启动时间" style="zoom:50%"></li><li><p>接着，仍然是通过<code>SpringFactoriesLoader</code>的机制<strong>加载所有的<code>SpringApplicationRunListener</code>监听器</strong>。从名字就可以看出，<code>SpringApplicationRunListener</code> 的作用就是监听 SpringApplication.run 方法的各个执行阶段，也可以理解成 <code>SpringApplication</code> 运行的生命周期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SpringApplicationRunListeners listeners = getRunListeners(args);<br></code></pre></td></tr></table></figure></li><li><p>紧接着，<strong>启动已经准备好的监听器</strong>，准备启动应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">listeners.starting(bootstrapContext, <span class="hljs-keyword">this</span>.mainApplicationClass);<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>第二运行阶段</p></blockquote><ul><li><p>启动应用后，根据<code>ApplicationType类型</code>，<strong>创建并配置<code>SpringApplication</code>需要的环境参数</strong><code>Environment</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);<br>ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>configureIgnoreBeanInfo(environment);<br></code></pre></td></tr></table></figure></li><li><p>接下来，<strong>打印banner图案</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Banner printedBanner = printBanner(environment);<br></code></pre></td></tr></table></figure></li><li><p>下面，根据初始化时推断的<code>ApplicationType</code>结果，<strong>创建对应类型的<code>AoolicationContext</code>上下文</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">context = createApplicationContext();<br>context.setApplicationStartup(<span class="hljs-keyword">this</span>.applicationStartup);<br></code></pre></td></tr></table></figure></li><li><p>创建好Spring应用上下文后，就进入<strong>准备Spring应用上下文阶段</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContext</span><span class="hljs-params">(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,</span></span><br><span class="hljs-function"><span class="hljs-params">                            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span><br><span class="hljs-function"><span class="hljs-params">                            ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;<br>    context.setEnvironment(environment);<br>    postProcessApplicationContext(context);<br>    applyInitializers(context);<br>    listeners.contextPrepared(context);<br>    bootstrapContext.close(context);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br>        logStartupInfo(context.getParent() == <span class="hljs-keyword">null</span>);<br>        logStartupProfileInfo(context);<br>    &#125;<br>    <span class="hljs-comment">// Add boot specific singleton beans</span><br>    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();<br>    beanFactory.registerSingleton(<span class="hljs-string">&quot;springApplicationArguments&quot;</span>, applicationArguments);<br>    <span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-keyword">null</span>) &#123;<br>        beanFactory.registerSingleton(<span class="hljs-string">&quot;springBootBanner&quot;</span>, printedBanner);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) &#123;<br>        ((DefaultListableBeanFactory) beanFactory)<br>        .setAllowBeanDefinitionOverriding(<span class="hljs-keyword">this</span>.allowBeanDefinitionOverriding);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lazyInitialization) &#123;<br>        context.addBeanFactoryPostProcessor(<span class="hljs-keyword">new</span> LazyInitializationBeanFactoryPostProcessor());<br>    &#125;<br>    <span class="hljs-comment">// Load the sources</span><br>    Set&lt;Object&gt; sources = getAllSources();<br>    Assert.notEmpty(sources, <span class="hljs-string">&quot;Sources must not be empty&quot;</span>);<br>    load(context, sources.toArray(<span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]));<br>    listeners.contextLoaded(context);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>在这个方法中，我们看看做了哪些操作：</p><ul><li><p>设置spring应用上下文的environment</p></li><li><p>Spring应用上下文后置处理</p></li><li><p>提供类型转换器</p></li><li><p>执行Spring的初始化器 ApplicationContextInitializer</p></li><li><p>触发ApplicationContextInitializedEvent事件</p></li><li><p>注册单例Bean实例</p></li><li><p>加载Spring应用上下文的配置源到BeanDefinitionMap</p></li><li><p>触发ApplicationEvent事件，最后执行 SpringApplicationRunListeners 的 contextLoaded 阶段方法，表示 ApplicationContext 完成加载但还未启动，同时向 Spring Boot 监听器发布 ApplicationPreparedEvent 事件</p></li></ul><ul><li><p><strong>刷新Spring应用上下文</strong>，这一阶段，做了这三件事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">refreshContext(context);<br></code></pre></td></tr></table></figure><ul><li>bean工厂加载</li><li>通过工厂shengcahnbean</li><li>刷新生命周期</li></ul></li><li><p>然后，<strong>进行上下文后置结束处理<code>afterRefresh</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">afterRefresh(context, applicationArguments);<br></code></pre></td></tr></table></figure></li><li><p>然后<strong>发布应用，通知所有监听器进行工作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br>    <span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);<br>&#125;<br>listeners.started(context);<br></code></pre></td></tr></table></figure></li><li><p>检查当前的Spring容器中是否有<code>ApplicationRunner</code> 和 <code>CommandLineRunner</code>类型的bean，如果有的话就遍历执行它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">callRunners(context, applicationArguments);<br></code></pre></td></tr></table></figure></li><li><p>最后，<strong>启动监听</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">listeners.running(context);<br></code></pre></td></tr></table></figure></li></ul><p>至此，整个run方法执行结束，Spring应用也完成了整个启动流程。</p><p>下面是一张流程图，仅供参考：</p><p><img src="/posts/2021/01/07/SpringBoot%E7%AC%94%E8%AE%B002-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/run.png" srcset="/img/loading.gif" alt="run方法流程图"></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/SpringBoot/">SpringBoot</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/posts/2021/01/06/SpringBoot%E7%AC%94%E8%AE%B001-%E9%81%87%E8%A7%81SpringBoot/"><span class="hidden-mobile">SpringBoot笔记01-遇见SpringBoot</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><div id="gitalk-container"></div><script type="text/javascript">Fluid.utils.waitElementVisible("gitalk-container",(function(){Fluid.utils.createCssLink("/css/gitalk.css"),Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.min.js",(function(){new Gitalk({clientID:"af550312a411b96c64b9",clientSecret:"f11934265fd18324cb2d9fd605d7d445207a3e52",repo:"gitalk",owner:"AtroxQW",admin:["AtroxQW"],id:"ebe7f5aa5166572cfae39c69152b034b",language:"zh-CN",labels:["Gitalk"],perPage:10,pagerDirection:"last",createIssueManually:!0,distractionFreeMode:!1}).render("gitalk-container")}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>document.querySelector("#local-search-input").onclick=function(){searchFunc("/local-search.xml","local-search-input","local-search-result"),this.onclick=null}</script><script src="/js/boot.js"></script><script src="https://libs.xiaoz.top/instantclick/instantclick.min.js" data-no-instant></script><script data-no-instant>InstantClick.init()</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>